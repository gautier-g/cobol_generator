Reponds uniquement avec du code COBOL compilable, sans Markdown ni texte autour.
La premiere ligne doit etre IDENTIFICATION DIVISION.
Un seul PROGRAM-ID, pas de sous-programmes.
Utilise strictement les identifiants, messages, SQL et sequences definis dans la spec.
N'invente aucune variable, paragraphe, message ou SQL.
Respecte exactement les listes de WORKING-STORAGE, LINKAGE et USING.
Connexion SQL: n'ecris jamais de valeurs en dur (hote/user/mdp/base), utilise uniquement les variables de la spec ou l'environnement externe.
Toujours utiliser les terminateurs explicites END-IF / END-EVALUATE / END-PERFORM / END-EXEC.
Pas de GO TO, pas de logique DAL dans LOGIC, pas de SQL hors DAL.
Toute variable utilisee doit etre declaree (WORKING-STORAGE ou LINKAGE).
REGLE ABSOLUE PARAGRAPHES: Le nom ET le point sur la MEME ligne. Format: CALCULATE-FEES. JAMAIS de ligne avec juste un point apres.
REGLE ABSOLUE EXEC SQL INCLUDE: EXEC SQL INCLUDE SQLCA END-EXEC. (avec point final). Autres instructions COBOL sans point final.
REGLE ABSOLUE QUALIFICATION: Sous-champs avec OF obligatoire. Format: AMOUNT-BRUT OF OPERATION-REC.
Dans DATA DIVISION (WORKING-STORAGE/LINKAGE), toute ligne 01/05/77/88 avec PIC ou VALUE doit se terminer par un point. Regle non applicable en PROCEDURE DIVISION.

=== FONCTIONS INTRINSÈQUES GNUCOBOL (CRITIQUE) ===
GnuCOBOL supporte un ensemble LIMITÉ de fonctions intrinsèques.

FONCTIONS DISPONIBLES (utilise UNIQUEMENT ces fonctions):
- FUNCTION INTEGER(x)      : Partie entière (tronque vers zéro)
- FUNCTION ANINT(x)        : Arrondi au plus proche
- FUNCTION MOD(x, y)       : Modulo
- FUNCTION MAX(x, y, ...)  : Maximum
- FUNCTION MIN(x, y, ...)  : Minimum
- FUNCTION ABS(x)          : Valeur absolue
- FUNCTION LENGTH(x)       : Longueur chaîne
- FUNCTION UPPER-CASE(x)   : Majuscules
- FUNCTION LOWER-CASE(x)   : Minuscules
- FUNCTION TRIM(x)         : Supprimer espaces
- FUNCTION CURRENT-DATE    : Date/heure système
- FUNCTION WHEN-COMPILED   : Date compilation
- FUNCTION NUMVAL(x)       : Convertir string en numérique

FONCTIONS NON DISPONIBLES (N'EXISTENT PAS):
❌ FUNCTION CEILING(x)  : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION CEIL(x)     : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION FLOOR(x)    : N'existe pas! Utilise INTEGER(x) à la place
❌ FUNCTION ROUND(x, n) : N'existe pas! Utilise COMPUTE ... ROUNDED à la place
❌ FUNCTION SQRT(x)     : N'existe pas!
❌ FUNCTION POW(x, y)   : N'existe pas!
❌ FUNCTION EXP(x)      : N'existe pas!
❌ FUNCTION LOG(x)      : N'existe pas!
❌ IF var NUMERIC = FALSE : N'existe pas! Utilise IF var IS NOT NUMERIC à la place

ARRONDI SUPÉRIEUR (équivalent CEILING):
Pour arrondir au supérieur, utilise cette technique:
  COMPUTE result = FUNCTION INTEGER(value + 0.999)

EXEMPLE CEILING:
  value = 5.2  → FUNCTION INTEGER(5.2 + 0.999) = INTEGER(6.199) = 6  ✓
  value = 5.0  → FUNCTION INTEGER(5.0 + 0.999) = INTEGER(5.999) = 5  ✓
  value = -3.5 → FUNCTION INTEGER(-3.5 + 0.999) = INTEGER(-2.501) = -2  ✓

ARRONDI STANDARD:
Préfère toujours COMPUTE ... ROUNDED au lieu de FUNCTION:
   CORRECT:   COMPUTE result ROUNDED = value1 * value2
  ❌ INTERDIT:  COMPUTE result = FUNCTION ROUND(value1 * value2)

VALIDATION NUMERIC:
Utilise IS NUMERIC ou IS NOT NUMERIC pour tester si un champ alphanumérique contient des chiffres:
   CORRECT:   IF var IS NUMERIC THEN ...
   CORRECT:   IF var IS NOT NUMERIC THEN ...
  ❌ INTERDIT:  IF var NUMERIC = FALSE ...

IMPORTANT: Si tu dois arrondir, utilise COMPUTE ROUNDED, PAS FUNCTION ROUND.

ERREUR DE COMPILATION SI TU UTILISES UNE FONCTION INEXISTANTE:
Si tu génères FUNCTION CEILING, CEIL, FLOOR, ROUND, SQRT, POW, etc.,
le compilateur GnuCOBOL retournera: "erreur : FUNCTION « XXX » inconnue"
et la compilation ÉCHOUERA.


=== COUCHE BUSINESS : PRÉSENTATION UNIQUEMENT (CRITIQUE) ===
La couche BUSINESS génère UNIQUEMENT de l'affichage (présentation des données).

RÈGLES STRICTES POUR BUSINESS:
1. WORKING-STORAGE SECTION doit être VIDE (aucune variable)
2. UN SEUL paragraphe : celui spécifié dans fonctions (ex: DISPLAY-OPERATION)
3. UNIQUEMENT des instructions DISPLAY
4. UNIQUEMENT le statement obligatoire final (GOBACK)

AUTORISÉ DANS BUSINESS:
- DISPLAY 'texte'
- DISPLAY variable-linkage
- DISPLAY 'label' variable-linkage
- GOBACK (ou STOP RUN si spécifié)

STRICTEMENT INTERDIT DANS BUSINESS:
- ❌ COMPUTE, ADD, SUBTRACT, MULTIPLY, DIVIDE (calculs → LOGIC)
- ❌ IF, ELSE, EVALUATE, WHEN (logique → LOGIC)
- ❌ PERFORM (appels → LOGIC)
- ❌ CALL (appels → LOGIC)
- ❌ MOVE (sauf MOVE ... TO variable de travail, mais pas de variables de travail!)
- ❌ EXEC SQL (SQL → DAL)
- ❌ Variables WORKING-STORAGE (doivent rester vides)
- ❌ Paragraphes multiples (un seul paragraphe autorisé)
- ❌ Logique métier (toutes les règles R1-R7 doivent être en LOGIC)
- ❌ Validations (IF pour contrôler valeurs → LOGIC)

ARCHITECTURE 3 COUCHES:
- DAL (Data Access Layer)    : EXEC SQL, accès base de données
- LOGIC (Orchestration)       : PERFORM, CALL, calculs métier, validations
- BUSINESS (Presentation)     : DISPLAY uniquement

EXEMPLE CORRECT (BUSINESS):
```cobol
DISPLAY-OPERATION.
    DISPLAY '----------------------------------------'
    DISPLAY 'PRODUIT   : ' LK-PROD-NAME
    DISPLAY 'STOCK ACT.: ' LK-STOCK-CURRENT
    DISPLAY 'QTE REAPP.: ' LK-REORDER-QTY
    DISPLAY '----------------------------------------'
    GOBACK
    .
```

EXEMPLE INCORRECT (BUSINESS):
```cobol
DISPLAY-OPERATION.
    PERFORM CALCULATE-REORDER    ← INTERDIT! Pas de PERFORM
    IF LK-STOCK-CURRENT < 0      ← INTERDIT! Pas de validation
        MOVE 'ERROR' TO STATUS   ← INTERDIT! Pas de logique
    END-IF
    COMPUTE REORDER-QTY = ...    ← INTERDIT! Pas de calcul
    DISPLAY 'PRODUIT   : ' LK-PROD-NAME
    GOBACK
    .
```

SI TU GÉNÈRES DE LA LOGIQUE DANS BUSINESS:
- Le code sera rejeté lors de la validation
- Tous les calculs, validations, et appels doivent être dans LOGIC
- BUSINESS reçoit des données déjà calculées via LINKAGE et les affiche

RAPPEL: Si les requirements contiennent des règles métier (R1-R7),
ces règles sont pour la couche LOGIC, PAS pour BUSINESS.
BUSINESS affiche simplement le résultat des calculs effectués par LOGIC.


=== STRATEGY ===
1) Construis d'abord le squelette COBOL complet (DIVISION/SECTION) dans l'ordre.
2) Insere les blocs WORKING-STORAGE/LINKAGE exacts fournis par la spec.
3) Ecris la PROCEDURE DIVISION en suivant le flow et les fonctions.
4) REGLE CRITIQUE FERMETURE: Pour toute fonction ouverte (OPEN cursor, EVALUATE, IF, PERFORM), tu DOIS la fermer (CLOSE, END-EVALUATE, END-IF, END-PERFORM).
5) Verifie la coherence: aucune variable/paragraphes inventes.

=== CONTEXT ===
Programme: ANTENNE-BUSINESS (couche business)
SGBD: postgres. Dialecte COBOL: gnucobol.
Table ANTENNE: ANTENNE_ID INT PK, ANTENNE_NOM VARCHAR(50), ANTENNE_REGION VARCHAR(50)

=== REQUIREMENTS ===
Exigences (spec):
Aucune (presentation seulement)

=== STYLE ===
Guidelines globales: Format FIXED: instructions commencent en colonne 8 (prefixe de 7 espaces).
Commentaires: '*' en colonne 7 (6 espaces + '*'), pas de commentaires '*>'.
Ne pas utiliser '>>SOURCE FORMAT FREE'.
PARAGRAPHES: Nom + point sur meme ligne. Format: MAIN-PROCESS. JAMAIS de point seul sur ligne.
En DATA DIVISION, chaque ligne 01/05/77/88 avec PIC ou VALUE se termine par un point.
Aucune ligne ne doit depasser 72 colonnes (format FIXED).
Si une instruction depasse 72 colonnes, la scinder sur plusieurs lignes.
Pour EXEC SQL FETCH/SELECT/UPDATE: mettre chaque variable hote sur sa propre ligne.
Ne pas mettre de point en fin de DISPLAY/GOBACK/STOP RUN/CALL/MOVE/IF (sauf EXEC SQL INCLUDE SQLCA END-EXEC.).
Utiliser des guillemets simples pour les messages DISPLAY.
Respecter l'ordre: IDENTIFICATION -> ENVIRONMENT -> DATA -> PROCEDURE.
Dans DATA: WORKING-STORAGE puis LINKAGE (si present).
Header commentaire (verbatim):

Style specifique: 

=== FORMAT ===
Format COBOL: line_format: fixed
indent_spaces: 7
max_line_length: 72
comment: column=7, prefix=*
literal_quotes: single
paragraph_terminator: .
allow_source_format_directive: False

=== NAMING ===
Conventions de nommage: variables_case=UPPER_SNAKE, programmes_case=UPPER-KEBAB
prefixes: flags=WS-, linkage=LK-, working_storage=WS-
paragraph_style: VERB-NOUN

=== ENVIRONMENT ===


=== INTERFACE ===
Interface CALL/USING: LK-ANTENNE: groupe ANTENNE (direction: in)

=== STRUCTURE ===
LINKAGE SECTION.
01 LK-ANTENNE.
    05 LK-ANTENNE-ID PIC 9(9).
    05 LK-ANTENNE-NOM PIC X(50).
    05 LK-ANTENNE-REGION PIC X(50).

PROCEDURE DIVISION USING LK-ANTENNE.

=== WORKING_STORAGE ===
WORKING-STORAGE SECTION.

=== LOGGING ===
----------------------------------------
ANTENNE   : 
ID        : 
NOM       : 
REGION    : 

=== CONSTRAINTS ===
Interdictions: EXEC SQL, STOP RUN, GO TO, *>
Paragraphes publics attendus: DISPLAY-ANTENNE
Paragraphes internes autorises: (none)
Entry paragraph: DISPLAY-ANTENNE

=== SKELETON ===
Squelette attendu (rappel structure):
IDENTIFICATION DIVISION.
PROGRAM-ID. ANTENNE-BUSINESS.


DATA DIVISION.
WORKING-STORAGE SECTION.
WORKING-STORAGE SECTION.
PROCEDURE DIVISION USING LK-ANTENNE.

=== FONCTIONS ===
- DISPLAY-ANTENNE: Affiche les informations principales de l antenne courante sur la console.
  visibility: public, required: True
  Inputs: ANTENNE.ANTENNE_ID, ANTENNE.ANTENNE_NOM, ANTENNE.ANTENNE_REGION
  Steps:
    - DISPLAY '----------------------------------------'
    - DISPLAY 'ANTENNE   : ' LK-ANTENNE-NOM
    - DISPLAY 'ID        : ' LK-ANTENNE-ID
    - DISPLAY 'REGION    : ' LK-ANTENNE-REGION
    - DISPLAY '----------------------------------------'
    - GOBACK

Tache : genere le programme COBOL complet respectant ces contraintes (code seulement).

Les erreurs suivantes ont été détectées, corrige-les strictement sans ajouter de texte explicatif:
- Point final interdit sur instruction (utiliser '.' uniquement sur ligne seule).
- Point final interdit sur instruction (utiliser '.' uniquement sur ligne seule).