Tu generes UNIQUEMENT une liste JSON de lignes de steps (liste de strings).
Pas de Markdown, pas d'explications, pas de code complet.
Chaque ligne doit tenir sur 72 colonnes max (format fixed).
Si une condition est longue, decoupe en IF imbriques ou EVALUATE.
Utilise END-IF/END-PERFORM/END-EVALUATE.

=== REGLES STRICTES (CRITIQUE) ===
1. Format JSON uniquement: ["step1", "step2", ...]
2. Pas d'indentation dans les steps (sera ajoutee plus tard)
3. Maximum 72 colonnes par ligne
4. N'invente JAMAIS de variables ou CALL targets
5. Utilise UNIQUEMENT les mots-cles COBOL minimaux (voir liste ci-dessous)

=== MOTS-CLES COBOL AUTORISES ===
IF, ELSE, END-IF, END-CALL, MOVE, COMPUTE, ROUNDED, ADD, SUBTRACT, MULTIPLY, DIVIDE,
DISPLAY, PERFORM, CALL, EVALUATE, WHEN, END-EVALUATE, END-PERFORM, FUNCTION,
EXEC SQL, END-EXEC, OPEN, FETCH, CLOSE, COMMIT, ROLLBACK,
IS NUMERIC, IS NOT NUMERIC, EQUAL, NOT EQUAL, GREATER, LESS, ZERO, OF, IN,
CONTINUE, GOBACK, STOP RUN, INITIALIZE, SET, ACCEPT, FROM, ENVIRONMENT, UPON, SPACE, SPACES

=== IDENTIFIANTS (CRITIQUE) ===
N'invente JAMAIS de variables: utilise UNIQUEMENT les identifiants de la liste 'IDENTIFIANTS AUTORISES'.
Chaque identifiant (WS-*, LK-*, nom de champ) doit exister dans cette liste.
Syntaxe structure: AUTORISE 'FIELD OF STRUCTURE' ou champ direct 'FIELD'.
INTERDIT: notation pointee (STRUCTURE.FIELD), identifiants non declares.
NOTE: Si tu vois SALARY-BRUT et EMPLOYEE dans la liste, tu peux utiliser:
  - 'SALARY-BRUT' seul (prefere)
  - 'SALARY-BRUT OF EMPLOYEE' (acceptable si necessaire pour clarte)

=== EXEMPLES VALIDES ===
  MOVE SALARY-BRUT TO WS-BRUT
  MOVE SALARY-BRUT OF EMPLOYEE TO WS-BRUT
  COMPUTE SALARY-NET ROUNDED = WS-BRUT * 0.7
  IF WS-BRUT IS NOT NUMERIC
  IF WS-TOTAL < 0
  DISPLAY 'Erreur: salaire invalide'
  CALL 'PROGRAM-NAME' USING PARAM1 PARAM2 PARAM3  <- Utilise TOUS les params de l'interface
  PERFORM CALCULATE-TOTAL
  END-IF

=== EXEMPLES INVALIDES ===
  MOVE EMPLOYEE.SALARY TO WS-TOTAL  <- INTERDIT (notation pointee)
  COMPUTE WS-NEW-VAR = 100  <- INTERDIT (WS-NEW-VAR non declare)
  IF SALARY IS NEGATIVE  <- INTERDIT (n'existe pas, utilise: IF SALARY < 0)
  IF SALARY IS NOT NULL  <- INTERDIT hors SQL (utilise IS NOT NUMERIC)
  CALL 'INVENTED-PROGRAM'  <- INTERDIT (pas dans liste CALL TARGETS)
  CALL 'PROGRAM' USING PARAM1  <- INTERDIT si l'interface definit 3 params (manque PARAM2, PARAM3)
  PERFORM DAL-SAVE dans LOGIC  <- INTERDIT (CALL le programme DAL, pas PERFORM)

=== INTERDICTIONS (CRITIQUE) ===
INTERDIT: divisions/sections, PROGRAM-ID, paragraphes (labels avec point), DATA/WS/LINKAGE.
INTERDIT: ligne avec un seul point.
INTERDIT: identifiants non declares ou inventes.
INTERDIT: IS NEGATIVE, IS POSITIVE (n'existent pas en COBOL, utilise < 0, > 0).
INTERDIT: IS NULL hors EXEC SQL (dans COBOL normal, utilise IS NOT NUMERIC).
INTERDIT: CALL vers programme non liste dans CALL TARGETS.
SCOPE: uniquement les instructions du paragraphe courant (pas de nouveaux paragraphes).

=== BONNES PRATIQUES (recommandations) ===
PREFERE: COMPUTE ROUNDED au lieu de FUNCTION ROUND (plus simple).
PREFERE: Pas de END-COMPUTE (pas necessaire en COBOL, juste COMPUTE suffit).
AUTORISE mais moins bien: FUNCTION ROUND(...) est valide mais verbose.

=== FORMAT DE SORTIE ===
JSON uniquement, pas d'espaces en debut de ligne (l'indentation sera ajoutee plus tard).
Format: ["instruction 1", "instruction 2", ...]
Les steps doivent etre exploitables par un generateur COBOL.

=== PRINCIPE DE MINIMALISME ===
Genere le minimum d'instructions necessaires pour satisfaire les exigences.
Evite les variables intermediaires inutiles.
Privilegie les COMPUTE directs plutot que MOVE + ADD + MOVE.

=== FONCTIONS INTRINSÈQUES GNUCOBOL (CRITIQUE) ===
GnuCOBOL supporte un ensemble LIMITÉ de fonctions intrinsèques.

FONCTIONS DISPONIBLES (utilise UNIQUEMENT ces fonctions):
- FUNCTION INTEGER(x)      : Partie entière (tronque vers zéro)
- FUNCTION ANINT(x)        : Arrondi au plus proche
- FUNCTION MOD(x, y)       : Modulo
- FUNCTION MAX(x, y, ...)  : Maximum
- FUNCTION MIN(x, y, ...)  : Minimum
- FUNCTION ABS(x)          : Valeur absolue
- FUNCTION LENGTH(x)       : Longueur chaîne
- FUNCTION UPPER-CASE(x)   : Majuscules
- FUNCTION LOWER-CASE(x)   : Minuscules
- FUNCTION TRIM(x)         : Supprimer espaces
- FUNCTION CURRENT-DATE    : Date/heure système
- FUNCTION WHEN-COMPILED   : Date compilation
- FUNCTION NUMVAL(x)       : Convertir string en numérique

FONCTIONS NON DISPONIBLES (N'EXISTENT PAS):
❌ FUNCTION CEILING(x)  : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION CEIL(x)     : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION FLOOR(x)    : N'existe pas! Utilise INTEGER(x) à la place
❌ FUNCTION ROUND(x, n) : N'existe pas! Utilise COMPUTE ... ROUNDED à la place
❌ FUNCTION SQRT(x)     : N'existe pas!
❌ FUNCTION POW(x, y)   : N'existe pas!
❌ FUNCTION EXP(x)      : N'existe pas!
❌ FUNCTION LOG(x)      : N'existe pas!
❌ IF var NUMERIC = FALSE : N'existe pas! Utilise IF var IS NOT NUMERIC à la place

ARRONDI SUPÉRIEUR (équivalent CEILING):
Pour arrondir au supérieur, utilise cette technique:
  COMPUTE result = FUNCTION INTEGER(value + 0.999)

EXEMPLE CEILING:
  value = 5.2  → FUNCTION INTEGER(5.2 + 0.999) = INTEGER(6.199) = 6  ✓
  value = 5.0  → FUNCTION INTEGER(5.0 + 0.999) = INTEGER(5.999) = 5  ✓
  value = -3.5 → FUNCTION INTEGER(-3.5 + 0.999) = INTEGER(-2.501) = -2  ✓

ARRONDI STANDARD:
Préfère toujours COMPUTE ... ROUNDED au lieu de FUNCTION:
   CORRECT:   COMPUTE result ROUNDED = value1 * value2
  ❌ INTERDIT:  COMPUTE result = FUNCTION ROUND(value1 * value2)

VALIDATION NUMERIC:
Utilise IS NUMERIC ou IS NOT NUMERIC pour tester si un champ alphanumérique contient des chiffres:
   CORRECT:   IF var IS NUMERIC THEN ...
   CORRECT:   IF var IS NOT NUMERIC THEN ...
  ❌ INTERDIT:  IF var NUMERIC = FALSE ...

IMPORTANT: Si tu dois arrondir, utilise COMPUTE ROUNDED, PAS FUNCTION ROUND.

ERREUR DE COMPILATION SI TU UTILISES UNE FONCTION INEXISTANTE:
Si tu génères FUNCTION CEILING, CEIL, FLOOR, ROUND, SQRT, POW, etc.,
le compilateur GnuCOBOL retournera: "erreur : FUNCTION « XXX » inconnue"
et la compilation ÉCHOUERA.



=== SQL EMBARQUÉ OCESQL (CRITIQUE - PRIORITÉ ABSOLUE) ===
Contexte: workflow OCESQL en mode précompilation (ex: `ocesql file.cbl file.cob`).
Le fichier source `.cbl` DOIT contenir du SQL EMBARQUÉ standard (`EXEC SQL ... END-EXEC`).
Le précompilateur traduit automatiquement les blocs `EXEC SQL` en appels runtime (ex: `CALL 'OCESQLExec' USING SQLCA ...`).
Donc: NE PAS écrire d'appels OCESQL* dans le `.cbl`.

1) RÈGLES ABSOLUES (à respecter même si des specs mentionnent OCESQL*)
INTERDIT dans le `.cbl` source:
❌ CALL 'OCESQLStartSQL' ...
❌ CALL 'OCESQLConnect' ...
❌ CALL 'OCESQLEndSQL' ...
❌ CALL 'OCESQLExec' ...
❌ CALL 'OCESQLDisconnect' ...
❌ EXEC SQL CALL OCESQL... END-EXEC

Toujours utiliser uniquement:
 EXEC SQL <statement SQL standard> END-EXEC

2) RÈGLES DE FORME (évite les sorties qui compilent mais ne marchent pas)
- Chaque bloc SQL DOIT être complet et fermé:
   commence par `EXEC SQL`
   se termine par `END-EXEC` sur la même instruction
  ❌ INTERDIT: une ligne `EXEC SQL` seule (sans statement)
  ❌ INTERDIT: un `DECLARE ...` séparé sans `EXEC SQL ... END-EXEC` complet

- Ne jamais dupliquer SQLCA:
   `EXEC SQL INCLUDE SQLCA END-EXEC.` doit exister UNE seule fois en WORKING-STORAGE
  ❌ ne jamais générer `INCLUDE SQLCA` dans PROCEDURE / steps

3) CONNEXION / COMMIT / DÉCONNEXION (formes attendues)
CONNEXION:
- Utiliser EXEC SQL CONNECT avec des variables hote (utilisateur, mot de passe, base).
- Les noms exacts des variables doivent venir de la spec (WORKING-STORAGE), pas d'invention.

COMMIT:
 EXEC SQL COMMIT END-EXEC.

DÉCONNEXION:
 EXEC SQL DISCONNECT ALL END-EXEC.

IMPORTANT (HOST VARIABLES pour CONNECT):
Les host variables SQL `:var` doivent etre des champs ELEMENTAIRES COBOL.
Si un identifiant est un GROUPE et qu'il existe un champ elementaire associe,
ALORS utiliser le champ elementaire (pas le GROUPE) dans la connexion.

4) CURSEURS (ordre obligatoire + séquence complète)
RÈGLE: l'ordre est STRICT et la séquence doit être cohérente dans le même paragraphe/flux.
Tu ne peux pas OPEN/FETCH un curseur non déclaré.

 ÉTAPE 1 — DECLARE (AVANT toute utilisation, généralement en début de paragraphe ou section dédiée):
    EXEC SQL DECLARE cursor-name CURSOR FOR
        SELECT col1, col2 FROM table
    END-EXEC

 ÉTAPE 2 — OPEN (APRÈS DECLARE):
    EXEC SQL OPEN cursor-name END-EXEC

 ÉTAPE 3 — FETCH (APRÈS OPEN):
    EXEC SQL FETCH cursor-name INTO :var1, :var2 END-EXEC

 ÉTAPE 4 — CLOSE (APRÈS FETCH et avant sortie du flux):
    EXEC SQL CLOSE cursor-name END-EXEC

INTERDIT / erreurs fréquentes:
❌ OPEN sans DECLARE
❌ DECLARE placé après OPEN (ou en fin de fichier)
❌ `EXEC SQL` isolé sans statement
❌ FETCH avant OPEN
❌ CLOSE avant OPEN/FETCH

5) RÈGLE ABSOLUE ANTI-TRAILING SPACES (données enum/status)
Les champs COBOL `PIC X(n)` sont space-padded. Si tu écris directement `:WS-STATUS` en base,
la base stocke souvent `OK       ` / `LOW       ` / `BLOCKED   ` au lieu de `OK` / `LOW` / `BLOCKED`.
Ça casse ensuite les comparaisons exactes (`WHERE status = 'OK'`) et les tests stricts.

Donc, pour les colonnes de type "enum/status/short string" (ex: risk_level, compliance_status, etc.),
tu DOIS normaliser côté SQL lors de l'UPDATE/INSERT (sans changer la valeur logique):

 CORRECT (normalisation côté SQL):
    EXEC SQL UPDATE OPERATION
        SET RISK_LEVEL = RTRIM(:WS-RISK-LEVEL),
            COMPLIANCE_STATUS = RTRIM(:WS-COMPLIANCE-STATUS)
        WHERE OP_ID = :WS-OP-ID
    END-EXEC

 Alternative acceptable (si RTRIM non souhaité):
    utiliser TRIM(:var) (TRIM = enlever espaces des deux côtés)

❌ FAUX (stocke la valeur paddée):
    EXEC SQL UPDATE OPERATION
        SET RISK_LEVEL = :WS-RISK-LEVEL
        WHERE OP_ID = :WS-OP-ID
    END-EXEC

6) CHECK ERREUR SQL (pattern attendu)
Après un CONNECT/UPDATE/INSERT/SELECT important, vérifier SQLCODE:

    IF SQLCODE NOT EQUAL ZERO
        DISPLAY 'ERREUR SQL: SQLCODE=' SQLCODE
        GOBACK
    END-IF

RAPPEL:
- Tu n'écris PAS les appels OCESQL* dans le `.cbl`.
- Tu écris du `EXEC SQL ... END-EXEC` standard.
- Host variables: champs élémentaires (préférer `*-TEXT` si un groupe existe).
- Curseurs: DECLARE → OPEN → FETCH → CLOSE, dans cet ordre strict.
- Enum/status: RTRIM/TRIM à l'écriture SQL pour éviter les espaces stockés.



=== CONTEXTE ===
Programme: UTILISATEUR-DAL-DB
Couche: dal
Entite: UTILISATEUR
Fonction: DAL-READ (required=True)
Description: Ouvre le curseur C_USER si necessaire, fait un FETCH et remplit la structure UTILISATEUR. Met END-OF-FILE a 'Y' en cas de fin de donnees ou d erreur.

=== SEPARATION DES COUCHES (CRITIQUE) ===
COUCHE DAL: Tu generes du code d'acces aux donnees UNIQUEMENT.
- AUTORISE: EXEC SQL, OPEN, FETCH, CLOSE, MOVE variables SQL
- INTERDIT: COMPUTE, calculs metier, logique business
- SCOPE: Lecture/ecriture base de donnees, pas de traitement
NOTE DAL: Tu DOIS respecter l'ordre des actions SQL ci-dessous.
Si 'declare_cursor' est present, DECLARE doit apparaitre avant OPEN.
Si 'open_cursor' est present, OPEN doit apparaitre avant FETCH.

=== POLITIQUE COMMIT POUR DAL-READ (CRITIQUE) ===
❌ INTERDIT: EXEC SQL COMMIT END-EXEC

Raison: cursor_commit_policy = no_commit_while_open
Cette fonction fait partie du traitement (READ/SAVE/UPDATE/etc.).
COMMIT fermerait le curseur et causerait SQLCODE=-400 sur le prochain FETCH.

 UTILISE A LA PLACE:
  - Pour erreurs: EXEC SQL ROLLBACK END-EXEC
  - Pour success: NE RIEN FAIRE (le COMMIT sera fait dans la fonction END)

IMPORTANT: Si tu generes 'EXEC SQL COMMIT END-EXEC' dans DAL-READ,
le programme plantera apres le premier enregistrement avec SQLCODE=-400.


=== CALL TARGETS AUTORISES ===
Programmes COBOL:
  - ACTIVITE-BUSINESS
    Parametres USING (dans l'ordre):
      LK-ACTIVITE [groupe ACTIVITE] (in)

  - ACTIVITE-DAL-DB
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-ACTIVITE [groupe ACTIVITE] (inout)

  - ACTIVITE-LOGIC
  - ANTENNE-BUSINESS
    Parametres USING (dans l'ordre):
      LK-ANTENNE [groupe ANTENNE] (in)

  - ANTENNE-DAL-DB
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-ANTENNE [groupe ANTENNE] (inout)

  - ANTENNE-LOGIC
  - HEBERGEMENT-BUSINESS
    Parametres USING (dans l'ordre):
      LK-HEBERGEMENT [groupe HEBERGEMENT] (in)

  - HEBERGEMENT-DAL-DB
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-HEBERGEMENT [groupe HEBERGEMENT] (inout)

  - HEBERGEMENT-LOGIC
  - PARTICIPATION-BUSINESS
    Parametres USING (dans l'ordre):
      LK-PARTICIPATION [groupe PARTICIPATION] (in)

  - PARTICIPATION-DAL-DB
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-PARTICIPATION [groupe PARTICIPATION] (inout)

  - PARTICIPATION-LOGIC
  - REPAS-BUSINESS
    Parametres USING (dans l'ordre):
      LK-REPAS [groupe REPAS] (in)

  - REPAS-DAL-DB
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-REPAS [groupe REPAS] (inout)

  - REPAS-LOGIC
  - UTILISATEUR-BUSINESS
    Parametres USING (dans l'ordre):
      LK-UTILISATEUR [groupe UTILISATEUR] (in)

  - UTILISATEUR-LOGIC
IMPORTANT: N'utilise QUE les programmes listes ci-dessus. Inventer un CALL est INTERDIT.

CRITIQUE: Pour chaque CALL vers un programme, tu DOIS passer TOUS les parametres listes
dans 'Parametres USING (dans l'ordre)' ci-dessus, dans le MEME ORDRE, a CHAQUE appel.
Exemple: Si un programme attend 3 parametres (A, B, C), tu dois TOUJOURS faire:
  CALL 'PROGRAMME' USING A B C
JAMAIS juste 'CALL PROGRAMME USING A' ou 'CALL PROGRAMME USING A B'.
Les parametres sont OBLIGATOIRES et definis par la LINKAGE SECTION du programme appele.

=== PARAGRAPHES AUTORISES (PERFORM) ===
DAL-CONNECT, DAL-SET-ENV, DAL-READ, DAL-SAVE, DAL-END
IMPORTANT: Utilise PERFORM uniquement vers les paragraphes listes ci-dessus.

=== ENTREES / SORTIES (noms COBOL uniquement) ===
Inputs: (aucun)
Outputs: END-OF-FILE, SQLCODE
Modifies: END-OF-FILE, SQLCODE, WS-CONNECTED, WS-CURSOR-OPEN

=== CHAMPS / STRUCTURE ===
USER-ID [9(9)] (INT, not null)
USER-NOM [X(50)] (VARCHAR(50), not null)
USER-MAIL [X(80)] (VARCHAR(80), not null)
USER-PASS [X(256)] (VARCHAR(256), not null)
USER-ROLE [X(15)] (VARCHAR(15), not null)
USER-ID-ANTENNE [9(9)] (INT, not null)
USER-LAST-LOGIN [S9(11)] (BIGINT, nullable)

=== WORKING-STORAGE (verbatim) ===
01  WS-CONNECTED-FLAG      PIC X
01  WS-CURSOR-OPEN-FLAG    PIC X
01  WS-USER-ID             PIC 9(9).
01  WS-USER-NOM            PIC X(50).
01  WS-USER-MAIL           PIC X(80).
01  WS-USER-PASS           PIC X(256).
01  WS-USER-ROLE           PIC X(15).
01  WS-USER-ID-ANTENNE     PIC 9(9).
01  WS-USER-LAST-LOGIN     PIC S9(11).
01  WS-DB-NAME            PIC X(64).
01  WS-DB-USER            PIC X(64).
01  WS-DB-PASSWORD        PIC X(64).

=== LINKAGE PARAMETERS ===
LK-OPERATION [X(4)] (in)
LK-END-OF-FILE [X] (inout)
LK-UTILISATEUR [groupe UTILISATEUR] (inout)
IMPORTANT: Utilise ces noms exacts dans USING et dans les steps.

=== LINKAGE GROUP FIELDS (prefixe requis) ===
LK-UTILISATEUR:
  - LK-USER-ID
  - LK-USER-ID-ANTENNE
  - LK-USER-LAST-LOGIN
  - LK-USER-MAIL
  - LK-USER-NOM
  - LK-USER-PASS
  - LK-USER-ROLE
IMPORTANT: Ces noms LK-* doivent etre utilises pour les sous-champs des groupes.

=== CURSOR LIFECYCLE (CRITIQUE) ===
Si tu ouvres un curseur ici, tu DOIS le fermer dans DAL-END (ou sur EOF si specifie).
Ne pas re-declarer/re-ouvrir un curseur deja ouvert: utilise un flag WS-*.
A la fermeture, remettre le flag d'ouverture a la valeur false (spec).

=== FETCH -> LINKAGE (CRITIQUE) ===
Pour chaque variable WS- lue par FETCH, si un champ LK- correspondant existe
dans LK-UTILISATEUR, tu DOIS faire un MOVE WS-xxx TO LK-xxx OF LK-UTILISATEUR quand SQLCODE = 0.
Cela inclut les colonnes de JOIN (ex: WS-ANTENNE-NOM -> LK-ANTENNE-NOM).

=== SQL ACTIONS (ordre obligatoire) ===
declare_cursor -> open_cursor -> fetch_cursor -> check_sqlcode -> map_to_linkage -> set_eof

=== SQL (si applicable) ===
declare_cursor: DECLARE C_USER CURSOR FOR
SELECT USER_ID, USER_NOM, USER_MAIL, USER_PASS, USER_ROLE,
       USER_ID_ANTENNE, USER_LAST_LOGIN
FROM UTILISATEUR
ORDER BY USER_ID

fetch_into: FETCH C_USER INTO :WS-USER-ID, :WS-USER-NOM, :WS-USER-MAIL, :WS-USER-PASS, :WS-USER-ROLE, :WS-USER-ID-ANTENNE, :WS-USER-LAST-LOGIN
open_cursor: OPEN C_USER

=== DISPLAY SPEC (structure) ===
(aucune)

=== DISPLAY LINES (verbatim) ===
(aucune)

=== STATEMENTS OBLIGATOIRES ===
(aucun)

=== REGLES METIER (calculs et transformations) ===
[R4] Toutes les operations BD sont realisees en COBOL embarque SQL PostgreSQL (SQL embarque precompile).
NOTE: Ces regles definissent les calculs a effectuer (ex: SALARY_NET = BRUT * 0.7).

=== REGLES DE VALIDATION (controles) ===
Aucune
NOTE: Ces regles definissent les controles a effectuer AVANT calcul.
Pour tester NULL/invalide en COBOL normal: utilise 'IS NOT NUMERIC' (pas 'IS NULL').
Exemple: IF SALARY-BRUT IS NOT NUMERIC → traiter comme invalide.


=== LOGGING ===
Connexion DB reussie
ERREUR CONNECT: SQLCODE=
SQLSTATE=
SQLERRMC=
Curseur C_USER ouvert
ERREUR OPEN: SQLCODE=
ERREUR FETCH: SQLCODE=
ERREUR UPDATE: SQLCODE=
ERREUR CLOSE: SQLCODE=
ERREUR COMMIT: SQLCODE=
ERREUR DISCONNECT: SQLCODE=
ERREUR: Operation inconnue: 
Fermeture connexion

=== FORMAT ===
Format FIXED: instructions commencent en colonne 8 (prefixe de 7 espaces).
Commentaires: '*' en colonne 7 (6 espaces + '*'), pas de commentaires '*>'.
Ne pas utiliser '>>SOURCE FORMAT FREE'.
PARAGRAPHES: Nom + point sur meme ligne. Format: MAIN-PROCESS. JAMAIS de point seul sur ligne.
En DATA DIVISION, chaque ligne 01/05/77/88 avec PIC ou VALUE se termine par un point.
Aucune ligne ne doit depasser 72 colonnes (format FIXED).
Si une instruction depasse 72 colonnes, la scinder sur plusieurs lignes.
Pour EXEC SQL FETCH/SELECT/UPDATE: mettre chaque variable hote sur sa propre ligne.
Ne pas mettre de point en fin de DISPLAY/GOBACK/STOP RUN/CALL/MOVE/IF (sauf EXEC SQL INCLUDE SQLCA END-EXEC.).
Utiliser des guillemets simples pour les messages DISPLAY.
Respecter l'ordre: IDENTIFICATION -> ENVIRONMENT -> DATA -> PROCEDURE.
Dans DATA: WORKING-STORAGE puis LINKAGE (si present).

=== IDENTIFIANTS AUTORISES ===
DAL-CONNECT, DAL-END, DAL-READ, DAL-SAVE, DAL-SET-ENV, END-OF-FILE, LK-END-OF-FILE, LK-OPERATION, LK-USER-ID, LK-USER-ID-ANTENNE, LK-USER-LAST-LOGIN, LK-USER-MAIL, LK-USER-NOM, LK-USER-PASS, LK-USER-ROLE, LK-UTILISATEUR, SQLCA, SQLCODE, SQLERRMC, SQLSTATE, UTILISATEUR, WS-CONNECTED, WS-CONNECTED-FLAG, WS-CURSOR-OPEN, WS-CURSOR-OPEN-FLAG, WS-DB-NAME, WS-DB-PASSWORD, WS-DB-USER, WS-USER-ID, WS-USER-ID-ANTENNE, WS-USER-LAST-LOGIN, WS-USER-MAIL, WS-USER-NOM, WS-USER-PASS, WS-USER-ROLE

=== SORTIE ATTENDUE ===
Retourne un JSON valide: ["step 1", "step 2", ...]