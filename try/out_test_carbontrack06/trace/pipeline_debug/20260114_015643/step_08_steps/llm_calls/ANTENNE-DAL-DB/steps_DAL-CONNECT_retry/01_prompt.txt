!!! AVERTISSEMENT CRITIQUE - ERREUR DE COMPILATION FREQUENTE !!!

Ce programme contient des conditions 88-level SANS clause FALSE: WS-CONNECTED, WS-CURSOR-OPEN
Pour ces conditions, tu DOIS utiliser MOVE pour les desactiver:

  - Pour desactiver WS-CONNECTED: MOVE 'N' TO WS-CONNECTED-FLAG  (PAS 'SET WS-CONNECTED TO FALSE')
  - Pour desactiver WS-CURSOR-OPEN: MOVE 'N' TO WS-CURSOR-OPEN-FLAG  (PAS 'SET WS-CURSOR-OPEN TO FALSE')

Si tu utilises 'SET condition TO FALSE' sans clause FALSE declaree,
tu auras l'erreur: 'le champ n'a pas une clause FALSE' et la compilation ECHOUERA.
Voir section MANIPULATION DES CONDITIONS 88-LEVEL ci-dessous pour details.

======================================================================

Tu generes UNIQUEMENT une liste JSON de lignes de steps (liste de strings).
Pas de Markdown, pas d'explications, pas de code complet.
Chaque ligne doit tenir sur 72 colonnes max (format fixed).
Si une condition est longue, decoupe en IF imbriques ou EVALUATE.
Utilise END-IF/END-PERFORM/END-EVALUATE.

=== REGLES STRICTES (CRITIQUE) ===
1. Format JSON uniquement: ["step1", "step2", ...]
2. Pas d'indentation dans les steps (sera ajoutee plus tard)
3. Maximum 72 colonnes par ligne
4. N'invente JAMAIS de variables ou CALL targets
5. Utilise UNIQUEMENT les mots-cles COBOL minimaux (voir liste ci-dessous)

=== MOTS-CLES COBOL AUTORISES ===
IF, ELSE, END-IF, END-CALL, MOVE, COMPUTE, ROUNDED, ADD, SUBTRACT, MULTIPLY, DIVIDE,
DISPLAY, PERFORM, CALL, EVALUATE, WHEN, END-EVALUATE, END-PERFORM, FUNCTION,
EXEC SQL, END-EXEC, OPEN, FETCH, CLOSE, COMMIT, ROLLBACK,
IS NUMERIC, IS NOT NUMERIC, EQUAL, NOT EQUAL, GREATER, LESS, ZERO, OF, IN,
CONTINUE, GOBACK, STOP RUN, INITIALIZE, SET, ACCEPT

=== IDENTIFIANTS (CRITIQUE) ===
N'invente JAMAIS de variables: utilise UNIQUEMENT les identifiants de la liste 'IDENTIFIANTS AUTORISES'.
Chaque identifiant (WS-*, LK-*, nom de champ) doit exister dans cette liste.
Syntaxe structure: AUTORISE 'FIELD OF STRUCTURE' ou champ direct 'FIELD'.
INTERDIT: notation pointee (STRUCTURE.FIELD), identifiants non declares.
NOTE: Si tu vois SALARY-BRUT et EMPLOYEE dans la liste, tu peux utiliser:
  - 'SALARY-BRUT' seul (prefere)
  - 'SALARY-BRUT OF EMPLOYEE' (acceptable si necessaire pour clarte)

=== EXEMPLES VALIDES ===
  MOVE SALARY-BRUT TO WS-BRUT
  MOVE SALARY-BRUT OF EMPLOYEE TO WS-BRUT
  COMPUTE SALARY-NET ROUNDED = WS-BRUT * 0.7
  IF WS-BRUT IS NOT NUMERIC
  IF WS-TOTAL < 0
  DISPLAY 'Erreur: salaire invalide'
  CALL 'PROGRAM-NAME' USING PARAM1 PARAM2 PARAM3  <- Utilise TOUS les params de l'interface
  PERFORM CALCULATE-TOTAL
  END-IF

=== EXEMPLES INVALIDES ===
  MOVE EMPLOYEE.SALARY TO WS-TOTAL  <- INTERDIT (notation pointee)
  COMPUTE WS-NEW-VAR = 100  <- INTERDIT (WS-NEW-VAR non declare)
  IF SALARY IS NEGATIVE  <- INTERDIT (n'existe pas, utilise: IF SALARY < 0)
  IF SALARY IS NOT NULL  <- INTERDIT hors SQL (utilise IS NOT NUMERIC)
  CALL 'INVENTED-PROGRAM'  <- INTERDIT (pas dans liste CALL TARGETS)
  CALL 'PROGRAM' USING PARAM1  <- INTERDIT si l'interface definit 3 params (manque PARAM2, PARAM3)
  PERFORM DAL-SAVE dans LOGIC  <- INTERDIT (CALL le programme DAL, pas PERFORM)

=== INTERDICTIONS (CRITIQUE) ===
INTERDIT: divisions/sections, PROGRAM-ID, paragraphes (labels avec point), DATA/WS/LINKAGE.
INTERDIT: ligne avec un seul point.
INTERDIT: identifiants non declares ou inventes.
INTERDIT: IS NEGATIVE, IS POSITIVE (n'existent pas en COBOL, utilise < 0, > 0).
INTERDIT: IS NULL hors EXEC SQL (dans COBOL normal, utilise IS NOT NUMERIC).
INTERDIT: CALL vers programme non liste dans CALL TARGETS.
SCOPE: uniquement les instructions du paragraphe courant (pas de nouveaux paragraphes).

=== BONNES PRATIQUES (recommandations) ===
PREFERE: COMPUTE ROUNDED au lieu de FUNCTION ROUND (plus simple).
PREFERE: Pas de END-COMPUTE (pas necessaire en COBOL, juste COMPUTE suffit).
AUTORISE mais moins bien: FUNCTION ROUND(...) est valide mais verbose.

=== FORMAT DE SORTIE ===
JSON uniquement, pas d'espaces en debut de ligne (l'indentation sera ajoutee plus tard).
Format: ["instruction 1", "instruction 2", ...]
Les steps doivent etre exploitables par un generateur COBOL.

=== PRINCIPE DE MINIMALISME ===
Genere le minimum d'instructions necessaires pour satisfaire les exigences.
Evite les variables intermediaires inutiles.
Privilegie les COMPUTE directs plutot que MOVE + ADD + MOVE.

=== FONCTIONS INTRINSÈQUES GNUCOBOL (CRITIQUE) ===
GnuCOBOL supporte un ensemble LIMITÉ de fonctions intrinsèques.

FONCTIONS DISPONIBLES (utilise UNIQUEMENT ces fonctions):
- FUNCTION INTEGER(x)      : Partie entière (tronque vers zéro)
- FUNCTION ANINT(x)        : Arrondi au plus proche
- FUNCTION MOD(x, y)       : Modulo
- FUNCTION MAX(x, y, ...)  : Maximum
- FUNCTION MIN(x, y, ...)  : Minimum
- FUNCTION ABS(x)          : Valeur absolue
- FUNCTION LENGTH(x)       : Longueur chaîne
- FUNCTION UPPER-CASE(x)   : Majuscules
- FUNCTION LOWER-CASE(x)   : Minuscules
- FUNCTION TRIM(x)         : Supprimer espaces
- FUNCTION CURRENT-DATE    : Date/heure système
- FUNCTION WHEN-COMPILED   : Date compilation
- FUNCTION NUMVAL(x)       : Convertir string en numérique

FONCTIONS NON DISPONIBLES (N'EXISTENT PAS):
❌ FUNCTION CEILING(x)  : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION CEIL(x)     : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION FLOOR(x)    : N'existe pas! Utilise INTEGER(x) à la place
❌ FUNCTION ROUND(x, n) : N'existe pas! Utilise COMPUTE ... ROUNDED à la place
❌ FUNCTION SQRT(x)     : N'existe pas!
❌ FUNCTION POW(x, y)   : N'existe pas!
❌ FUNCTION EXP(x)      : N'existe pas!
❌ FUNCTION LOG(x)      : N'existe pas!
❌ IF var NUMERIC = FALSE : N'existe pas! Utilise IF var IS NOT NUMERIC à la place

ARRONDI SUPÉRIEUR (équivalent CEILING):
Pour arrondir au supérieur, utilise cette technique:
  COMPUTE result = FUNCTION INTEGER(value + 0.999)

EXEMPLE CEILING:
  value = 5.2  → FUNCTION INTEGER(5.2 + 0.999) = INTEGER(6.199) = 6  ✓
  value = 5.0  → FUNCTION INTEGER(5.0 + 0.999) = INTEGER(5.999) = 5  ✓
  value = -3.5 → FUNCTION INTEGER(-3.5 + 0.999) = INTEGER(-2.501) = -2  ✓

ARRONDI STANDARD:
Préfère toujours COMPUTE ... ROUNDED au lieu de FUNCTION:
  ✅ CORRECT:   COMPUTE result ROUNDED = value1 * value2
  ❌ INTERDIT:  COMPUTE result = FUNCTION ROUND(value1 * value2)

VALIDATION NUMERIC:
Utilise IS NUMERIC ou IS NOT NUMERIC pour tester si un champ alphanumérique contient des chiffres:
  ✅ CORRECT:   IF var IS NUMERIC THEN ...
  ✅ CORRECT:   IF var IS NOT NUMERIC THEN ...
  ❌ INTERDIT:  IF var NUMERIC = FALSE ...

IMPORTANT: Si tu dois arrondir, utilise COMPUTE ROUNDED, PAS FUNCTION ROUND.

ERREUR DE COMPILATION SI TU UTILISES UNE FONCTION INEXISTANTE:
Si tu génères FUNCTION CEILING, CEIL, FLOOR, ROUND, SQRT, POW, etc.,
le compilateur GnuCOBOL retournera: "erreur : FUNCTION « XXX » inconnue"
et la compilation ÉCHOUERA.


INTERDIT: SET WS-CONNECTED TO FALSE (cause erreur compilation, utilise MOVE 'N' TO WS-CONNECTED-FLAG)
INTERDIT: SET WS-CURSOR-OPEN TO FALSE (cause erreur compilation, utilise MOVE 'N' TO WS-CURSOR-OPEN-FLAG)

=== CONTEXTE ===
Programme: ANTENNE-DAL-DB
Couche: dal
Entite: ANTENNE
Fonction: DAL-CONNECT (required=True)
Description: Connexion paresseuse a la base via OCESQL. Initialise les variables d environnement PostgreSQL, puis execute OCESQLStartSQL/OCESQLConnect/OCESQLEndSQL.

=== SEPARATION DES COUCHES (CRITIQUE) ===
COUCHE DAL: Tu generes du code d'acces aux donnees UNIQUEMENT.
- AUTORISE: EXEC SQL, OPEN, FETCH, CLOSE, MOVE variables SQL
- INTERDIT: COMPUTE, calculs metier, logique business
- SCOPE: Lecture/ecriture base de donnees, pas de traitement

=== POLITIQUE COMMIT POUR DAL-CONNECT ===
⚠️  ATTENTION: cursor_commit_policy = no_commit_while_open
Si cette fonction fait partie d'un traitement avec curseur ouvert,
N'UTILISE PAS: EXEC SQL COMMIT END-EXEC (sauf si fonction de cloture/fin)


=== CALL TARGETS AUTORISES ===
Programmes COBOL:
  - ACTIVITE-BUSINESS
    Interface: CALL 'ACTIVITE-BUSINESS' USING LK-ACTIVITE.
    Parametres USING (dans l'ordre):
      LK-ACTIVITE [groupe ACTIVITE] (in)

  - ACTIVITE-DAL-DB
    Interface: CALL 'ACTIVITE-DAL-DB' USING OPERATION, END-OF-FILE, ACTIVITE.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-ACTIVITE [groupe ACTIVITE] (inout)

  - ACTIVITE-LOGIC
  - ANTENNE-BUSINESS
    Interface: CALL 'ANTENNE-BUSINESS' USING LK-ANTENNE.
    Parametres USING (dans l'ordre):
      LK-ANTENNE [groupe ANTENNE] (in)

  - ANTENNE-LOGIC
  - HEBERGEMENT-BUSINESS
    Interface: CALL 'HEBERGEMENT-BUSINESS' USING LK-HEBERGEMENT.
    Parametres USING (dans l'ordre):
      LK-HEBERGEMENT [groupe HEBERGEMENT] (in)

  - HEBERGEMENT-DAL-DB
    Interface: CALL 'HEBERGEMENT-DAL-DB' USING OPERATION, END-OF-FILE, HEBERGEMENT.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-HEBERGEMENT [groupe HEBERGEMENT] (inout)

  - HEBERGEMENT-LOGIC
  - PARTICIPATION-BUSINESS
    Interface: CALL 'PARTICIPATION-BUSINESS' USING LK-PARTICIPATION.
    Parametres USING (dans l'ordre):
      LK-PARTICIPATION [groupe PARTICIPATION] (in)

  - PARTICIPATION-DAL-DB
    Interface: CALL 'PARTICIPATION-DAL-DB' USING OPERATION, END-OF-FILE, PARTICIPATION.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-PARTICIPATION [groupe PARTICIPATION] (inout)

  - PARTICIPATION-LOGIC
  - REPAS-BUSINESS
    Interface: CALL 'REPAS-BUSINESS' USING LK-REPAS.
    Parametres USING (dans l'ordre):
      LK-REPAS [groupe REPAS] (in)

  - REPAS-DAL-DB
    Interface: CALL 'REPAS-DAL-DB' USING OPERATION, END-OF-FILE, REPAS.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-REPAS [groupe REPAS] (inout)

  - REPAS-LOGIC
  - UTILISATEUR-BUSINESS
    Interface: CALL 'UTILISATEUR-BUSINESS' USING LK-UTILISATEUR.
    Parametres USING (dans l'ordre):
      LK-UTILISATEUR [groupe UTILISATEUR] (in)

  - UTILISATEUR-DAL-DB
    Interface: CALL 'UTILISATEUR-DAL-DB' USING OPERATION, END-OF-FILE, UTILISATEUR.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-UTILISATEUR [groupe UTILISATEUR] (inout)

  - UTILISATEUR-LOGIC
IMPORTANT: N'utilise QUE les programmes listes ci-dessus. Inventer un CALL est INTERDIT.

CRITIQUE: Pour chaque CALL vers un programme, tu DOIS passer TOUS les parametres listes
dans 'Parametres USING (dans l'ordre)' ci-dessus, dans le MEME ORDRE, a CHAQUE appel.
Exemple: Si un programme attend 3 parametres (A, B, C), tu dois TOUJOURS faire:
  CALL 'PROGRAMME' USING A B C
JAMAIS juste 'CALL PROGRAMME USING A' ou 'CALL PROGRAMME USING A B'.
Les parametres sont OBLIGATOIRES et definis par la LINKAGE SECTION du programme appele.

=== PARAGRAPHES AUTORISES (PERFORM) ===
DAL-CONNECT, DAL-SET-ENV, DAL-READ, DAL-SAVE, DAL-END
IMPORTANT: Utilise PERFORM uniquement vers les paragraphes listes ci-dessus.

=== ENTREES / SORTIES (noms COBOL uniquement) ===
Inputs: (aucun)
Outputs: SQLCODE, SQLSTATE
Modifies: SQLCODE, WS-CONNECTED

=== CHAMPS / STRUCTURE ===
ANTENNE-ID [9(9)] (INT, not null)
ANTENNE-NOM [X(50)] (VARCHAR(50), not null)
ANTENNE-REGION [X(50)] (VARCHAR(50), not null)

=== WORKING-STORAGE (verbatim) ===
EXEC SQL INCLUDE SQLCA END-EXEC.
01  WS-CONNECTED-FLAG      PIC X VALUE 'N'.
88  WS-CONNECTED           VALUE 'Y'.
01  WS-CURSOR-OPEN-FLAG    PIC X VALUE 'N'.
88  WS-CURSOR-OPEN         VALUE 'Y'.
01  WS-ANTENNE-ID          PIC 9(9).
01  WS-ANTENNE-NOM         PIC X(50).
01  WS-ANTENNE-REGION      PIC X(50).
01  WS-DB-NAME.
05  WS-DB-NAME-TEXT     PIC X(13) VALUE 'carbontrackdb'.
05  WS-DB-NAME-TERM     PIC X VALUE X'00'.
01  WS-DB-USER.
05  WS-DB-USER-TEXT     PIC X(10) VALUE 'carbonuser'.
05  WS-DB-USER-TERM     PIC X VALUE X'00'.
01  WS-DB-PASSWORD.
05  WS-DB-PASSWORD-TEXT PIC X(9) VALUE 'CARBONPWD'.
05  WS-DB-PASSWORD-TERM PIC X VALUE X'00'.
01  WS-DB-NAME-LEN         PIC S9(4) COMP-5 VALUE 13.
01  WS-DB-USER-LEN         PIC S9(4) COMP-5 VALUE 10.
01  WS-DB-PASSWORD-LEN     PIC S9(4) COMP-5 VALUE 9.
01  WS-PGHOST-NAME         PIC X(6) VALUE 'PGHOST'.
01  WS-PGHOST-VALUE        PIC X(64) VALUE 'localhost'.
01  WS-PGPORT-NAME         PIC X(6) VALUE 'PGPORT'.
01  WS-PGPORT-VALUE        PIC X(5) VALUE '5432'.
01  WS-PGUSER-NAME         PIC X(6) VALUE 'PGUSER'.
01  WS-PGUSER-VALUE        PIC X(64) VALUE 'carbonuser'.
01  WS-PGPASSWORD-NAME     PIC X(10) VALUE 'PGPASSWORD'.
01  WS-PGPASSWORD-VALUE    PIC X(64) VALUE 'CARBONPWD'.
01  WS-PGDATABASE-NAME     PIC X(10) VALUE 'PGDATABASE'.
01  WS-PGDATABASE-VALUE    PIC X(64) VALUE 'carbontrackdb'.

=== QUALIFICATION DES CHAMPS (CRITIQUE) ===
ATTENTION: Les structures suivantes contiennent des sous-champs: WS-DB-NAME, WS-DB-USER, WS-DB-PASSWORD
REGLE ABSOLUE: Tous les sous-champs DOIVENT etre qualifies avec 'OF <structure>'.

Exemple pour WS-DB-NAME:
  CORRECT:   MOVE 100 TO FIELD-NAME OF WS-DB-NAME
  CORRECT:   COMPUTE RESULT OF WS-DB-NAME = VALUE1 OF WS-DB-NAME + VALUE2 OF WS-DB-NAME
  INCORRECT: MOVE 100 TO FIELD-NAME  <-- ERREUR AMBIGUITE

Exemple pour WS-DB-USER:
  CORRECT:   MOVE 100 TO FIELD-NAME OF WS-DB-USER
  CORRECT:   COMPUTE RESULT OF WS-DB-USER = VALUE1 OF WS-DB-USER + VALUE2 OF WS-DB-USER
  INCORRECT: MOVE 100 TO FIELD-NAME  <-- ERREUR AMBIGUITE

Exemple pour WS-DB-PASSWORD:
  CORRECT:   MOVE 100 TO FIELD-NAME OF WS-DB-PASSWORD
  CORRECT:   COMPUTE RESULT OF WS-DB-PASSWORD = VALUE1 OF WS-DB-PASSWORD + VALUE2 OF WS-DB-PASSWORD
  INCORRECT: MOVE 100 TO FIELD-NAME  <-- ERREUR AMBIGUITE

IMPORTANT: Dans les regles metier ci-dessous, les noms de champs (ex: FEE-AMOUNT, AMOUNT-BRUT)
font reference aux sous-champs de la structure appropriee.
Tu DOIS toujours qualifier ces champs avec 'OF <structure>' dans ton code COBOL.

=== MANIPULATION DES CONDITIONS 88-LEVEL (CRITIQUE) ===
ATTENTION: Cette section est CRITIQUE pour eviter des erreurs de compilation.
Les conditions 88-level ci-dessous ont des regles STRICTES en COBOL:

Conditions SANS clause FALSE (INTERDIT d'utiliser SET TO FALSE):

  - WS-CONNECTED (parent: WS-CONNECTED-FLAG, VALUE 'Y', PAS de clause FALSE)
    Pour activer  : SET WS-CONNECTED TO TRUE
    Pour desactiver: MOVE 'N' TO WS-CONNECTED-FLAG  <-- UTILISE CECI, PAS SET TO FALSE

  - WS-CURSOR-OPEN (parent: WS-CURSOR-OPEN-FLAG, VALUE 'Y', PAS de clause FALSE)
    Pour activer  : SET WS-CURSOR-OPEN TO TRUE
    Pour desactiver: MOVE 'N' TO WS-CURSOR-OPEN-FLAG  <-- UTILISE CECI, PAS SET TO FALSE

EXEMPLES CONCRETS POUR CE PROGRAMME:

  EXEMPLE CORRECT (utilise MOVE pour desactiver):
    IF WS-CONNECTED
        EXEC SQL CLOSE C_EMP END-EXEC
        MOVE 'N' TO WS-CONNECTED-FLAG  <-- CORRECT
    END-IF

  EXEMPLE INCORRECT (cause une erreur de compilation):
    IF WS-CONNECTED
        EXEC SQL CLOSE C_EMP END-EXEC
        SET WS-CONNECTED TO FALSE  <-- ERREUR! 'le champ n'a pas une clause FALSE'
    END-IF

RAPPEL CRITIQUE:
  - JAMAIS: SET WS-CONNECTED TO FALSE  (provoque: 'erreur: le champ n'a pas une clause FALSE')
  - TOUJOURS: MOVE 'N' TO WS-CONNECTED-FLAG  (pour desactiver la condition)

LISTE COMPLETE DES DESACTIVATIONS REQUISES:
  - Pour desactiver WS-CONNECTED: MOVE 'N' TO WS-CONNECTED-FLAG
  - Pour desactiver WS-CURSOR-OPEN: MOVE 'N' TO WS-CURSOR-OPEN-FLAG

=== LINKAGE PARAMETERS ===
LK-OPERATION [X(4)] (in)
LK-END-OF-FILE [X] (inout)
LK-ANTENNE [groupe ANTENNE] (inout)
IMPORTANT: Utilise ces noms exacts dans USING et dans les steps.

=== SQL ACTIONS (ordre obligatoire) ===
(aucune)

=== SQL (si applicable) ===
connection_calls: CALL "OCESQLStartSQL" END-CALL
connection_calls: CALL "OCESQLConnect" USING BY REFERENCE SQLCA BY REFERENCE WS-DB-USER BY VALUE WS-DB-USER-LEN BY REFERENCE WS-DB-PASSWORD BY VALUE WS-DB-PASSWORD-LEN BY REFERENCE WS-DB-NAME BY VALUE WS-DB-NAME-LEN END-CALL
connection_calls: CALL "OCESQLEndSQL" END-CALL
connection_method: OCESQL (voir sql.connection)

=== DISPLAY SPEC (structure) ===
(aucune)

=== DISPLAY LINES (verbatim) ===
(aucune)

=== STATEMENTS OBLIGATOIRES ===
GOBACK, END-CALL, BY REFERENCE, BY VALUE, EXIT PARAGRAPH, EVALUATE SQLCODE

=== REGLES METIER (calculs et transformations) ===
[R4] Toutes les operations BD sont realisees en COBOL embarque SQL PostgreSQL (OCESQL).
NOTE: Ces regles definissent les calculs a effectuer (ex: SALARY_NET = BRUT * 0.7).

=== REGLES DE VALIDATION (controles) ===
Aucune
NOTE: Ces regles definissent les controles a effectuer AVANT calcul.
Pour tester NULL/invalide en COBOL normal: utilise 'IS NOT NUMERIC' (pas 'IS NULL').
Exemple: IF SALARY-BRUT IS NOT NUMERIC → traiter comme invalide.


=== FLOW ===
MAIN-ENTRY: IF LK-OPERATION NOT = 'END ' THEN PERFORM DAL-CONNECT; IF NOT WS-CONNECTED THEN MOVE 'Y' TO LK-END-OF-FILE, GOBACK; END-IF; END-IF
EVALUATE LK-OPERATION: READ->DAL-READ, SAVE->DAL-SAVE, END->DAL-END, OTHER->DISPLAY erreur
GOBACK apres EVALUATE
DAL-READ: ouverture curseur paresseuse, FETCH, mise a jour EOF
DAL-SAVE: UPDATE ANTENNE_REGION
DAL-END: CLOSE cursor, COMMIT, DISCONNECT, reset flags

=== LOGGING ===
Connexion DB reussie: carbontrackdb
ERREUR CONNECT: SQLCODE=
SQLSTATE=
SQLERRMC=
Curseur C_ANT ouvert
ERREUR OPEN: SQLCODE=
ERREUR FETCH: SQLCODE=
ERREUR UPDATE: SQLCODE=
ERREUR CLOSE: SQLCODE=
ERREUR COMMIT: SQLCODE=
ERREUR DISCONNECT: SQLCODE=
ERREUR: Operation inconnue: 
Fermeture connexion

=== FORMAT ===
Format FIXED: instructions commencent en colonne 8 (prefixe de 7 espaces).
Commentaires: '*' en colonne 7 (6 espaces + '*'), pas de commentaires '*>'.
Ne pas utiliser '>>SOURCE FORMAT FREE'.
PARAGRAPHES: Nom + point sur meme ligne. Format: MAIN-PROCESS. JAMAIS de point seul sur ligne.
En DATA DIVISION, chaque ligne 01/05/77/88 avec PIC ou VALUE se termine par un point.
Aucune ligne ne doit depasser 72 colonnes (format FIXED).
Si une instruction depasse 72 colonnes, la scinder sur plusieurs lignes.
Pour EXEC SQL FETCH/SELECT/UPDATE: mettre chaque variable hote sur sa propre ligne.
Ne pas mettre de point en fin de DISPLAY/GOBACK/STOP RUN/CALL/MOVE/IF (sauf EXEC SQL INCLUDE SQLCA END-EXEC.).
Utiliser des guillemets simples pour les messages DISPLAY.
Respecter l'ordre: IDENTIFICATION -> ENVIRONMENT -> DATA -> PROCEDURE.
Dans DATA: WORKING-STORAGE puis LINKAGE (si present).

=== IDENTIFIANTS AUTORISES ===
ANTENNE, ANTENNE-ID, ANTENNE-NOM, ANTENNE-REGION, DAL-CONNECT, DAL-END, DAL-READ, DAL-SAVE, DAL-SET-ENV, LK-ANTENNE, LK-END-OF-FILE, LK-OPERATION, SQLCA, SQLCODE, SQLERRMC, SQLSTATE, WS-ANTENNE-ID, WS-ANTENNE-NOM, WS-ANTENNE-REGION, WS-CONNECTED, WS-CONNECTED-FLAG, WS-CURSOR-OPEN, WS-CURSOR-OPEN-FLAG, WS-DB-NAME, WS-DB-NAME-LEN, WS-DB-NAME-TERM, WS-DB-NAME-TEXT, WS-DB-PASSWORD, WS-DB-PASSWORD-LEN, WS-DB-PASSWORD-TERM, WS-DB-PASSWORD-TEXT, WS-DB-USER, WS-DB-USER-LEN, WS-DB-USER-TERM, WS-DB-USER-TEXT, WS-PGDATABASE-NAME, WS-PGDATABASE-VALUE, WS-PGHOST-NAME, WS-PGHOST-VALUE, WS-PGPASSWORD-NAME, WS-PGPASSWORD-VALUE, WS-PGPORT-NAME, WS-PGPORT-VALUE, WS-PGUSER-NAME, WS-PGUSER-VALUE

=== SORTIE ATTENDUE ===
Retourne un JSON valide: ["step 1", "step 2", ...]

=== ERREURS DE VALIDATION (CRITIQUE) ===
Ta reponse precedente contenait les erreurs suivantes:
  - line 3: CALL 'OCESQLStartSQL' must include USING SQLCA
  - line 11: CALL 'OCESQLConnect' must include USING SQLCA as first parameter
  - line 3: unknown identifiers ['OCESQLSTARTSQL']
  - line 11: unknown identifiers ['OCESQLCONNECT']
  - line 25: unknown identifiers ['OCESQLENDSQL']

Corrige ces erreurs en respectant STRICTEMENT:
1. N'utilise QUE les identifiants de la liste 'IDENTIFIANTS AUTORISES' (pas d'invention).
2. Utilise 'FIELD OF STRUCTURE' pour acceder aux champs (pas de notation pointee).
3. Respecte la limite de 72 colonnes par ligne.
4. Ne genere JAMAIS de DIVISION, SECTION, PROGRAM-ID, ou labels de paragraphe.
5. Retourne uniquement un JSON valide: ["step1", "step2", ...]

Si tu ne peux pas generer de steps valides, retourne [] uniquement.