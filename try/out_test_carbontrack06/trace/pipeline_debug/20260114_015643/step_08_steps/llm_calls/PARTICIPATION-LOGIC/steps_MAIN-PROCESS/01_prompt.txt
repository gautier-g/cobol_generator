!!! AVERTISSEMENT CRITIQUE - ERREUR DE COMPILATION FREQUENTE !!!

Ce programme contient des conditions 88-level SANS clause FALSE: EOF-REACHED, NOT-EOF
Pour ces conditions, tu DOIS utiliser MOVE pour les desactiver:

  - Pour desactiver EOF-REACHED: MOVE 'N' TO END-OF-FILE  (PAS 'SET EOF-REACHED TO FALSE')
  - Pour desactiver NOT-EOF: MOVE 'N' TO END-OF-FILE  (PAS 'SET NOT-EOF TO FALSE')

Si tu utilises 'SET condition TO FALSE' sans clause FALSE declaree,
tu auras l'erreur: 'le champ n'a pas une clause FALSE' et la compilation ECHOUERA.
Voir section MANIPULATION DES CONDITIONS 88-LEVEL ci-dessous pour details.

======================================================================

Tu generes UNIQUEMENT une liste JSON de lignes de steps (liste de strings).
Pas de Markdown, pas d'explications, pas de code complet.
Chaque ligne doit tenir sur 72 colonnes max (format fixed).
Si une condition est longue, decoupe en IF imbriques ou EVALUATE.
Utilise END-IF/END-PERFORM/END-EVALUATE.

=== REGLES STRICTES (CRITIQUE) ===
1. Format JSON uniquement: ["step1", "step2", ...]
2. Pas d'indentation dans les steps (sera ajoutee plus tard)
3. Maximum 72 colonnes par ligne
4. N'invente JAMAIS de variables ou CALL targets
5. Utilise UNIQUEMENT les mots-cles COBOL minimaux (voir liste ci-dessous)

=== MOTS-CLES COBOL AUTORISES ===
IF, ELSE, END-IF, END-CALL, MOVE, COMPUTE, ROUNDED, ADD, SUBTRACT, MULTIPLY, DIVIDE,
DISPLAY, PERFORM, CALL, EVALUATE, WHEN, END-EVALUATE, END-PERFORM, FUNCTION,
EXEC SQL, END-EXEC, OPEN, FETCH, CLOSE, COMMIT, ROLLBACK,
IS NUMERIC, IS NOT NUMERIC, EQUAL, NOT EQUAL, GREATER, LESS, ZERO, OF, IN,
CONTINUE, GOBACK, STOP RUN, INITIALIZE, SET, ACCEPT

=== IDENTIFIANTS (CRITIQUE) ===
N'invente JAMAIS de variables: utilise UNIQUEMENT les identifiants de la liste 'IDENTIFIANTS AUTORISES'.
Chaque identifiant (WS-*, LK-*, nom de champ) doit exister dans cette liste.
Syntaxe structure: AUTORISE 'FIELD OF STRUCTURE' ou champ direct 'FIELD'.
INTERDIT: notation pointee (STRUCTURE.FIELD), identifiants non declares.
NOTE: Si tu vois SALARY-BRUT et EMPLOYEE dans la liste, tu peux utiliser:
  - 'SALARY-BRUT' seul (prefere)
  - 'SALARY-BRUT OF EMPLOYEE' (acceptable si necessaire pour clarte)

=== EXEMPLES VALIDES ===
  MOVE SALARY-BRUT TO WS-BRUT
  MOVE SALARY-BRUT OF EMPLOYEE TO WS-BRUT
  COMPUTE SALARY-NET ROUNDED = WS-BRUT * 0.7
  IF WS-BRUT IS NOT NUMERIC
  IF WS-TOTAL < 0
  DISPLAY 'Erreur: salaire invalide'
  CALL 'PROGRAM-NAME' USING PARAM1 PARAM2 PARAM3  <- Utilise TOUS les params de l'interface
  PERFORM CALCULATE-TOTAL
  END-IF

=== EXEMPLES INVALIDES ===
  MOVE EMPLOYEE.SALARY TO WS-TOTAL  <- INTERDIT (notation pointee)
  COMPUTE WS-NEW-VAR = 100  <- INTERDIT (WS-NEW-VAR non declare)
  IF SALARY IS NEGATIVE  <- INTERDIT (n'existe pas, utilise: IF SALARY < 0)
  IF SALARY IS NOT NULL  <- INTERDIT hors SQL (utilise IS NOT NUMERIC)
  CALL 'INVENTED-PROGRAM'  <- INTERDIT (pas dans liste CALL TARGETS)
  CALL 'PROGRAM' USING PARAM1  <- INTERDIT si l'interface definit 3 params (manque PARAM2, PARAM3)
  PERFORM DAL-SAVE dans LOGIC  <- INTERDIT (CALL le programme DAL, pas PERFORM)

=== INTERDICTIONS (CRITIQUE) ===
INTERDIT: divisions/sections, PROGRAM-ID, paragraphes (labels avec point), DATA/WS/LINKAGE.
INTERDIT: ligne avec un seul point.
INTERDIT: identifiants non declares ou inventes.
INTERDIT: IS NEGATIVE, IS POSITIVE (n'existent pas en COBOL, utilise < 0, > 0).
INTERDIT: IS NULL hors EXEC SQL (dans COBOL normal, utilise IS NOT NUMERIC).
INTERDIT: CALL vers programme non liste dans CALL TARGETS.
SCOPE: uniquement les instructions du paragraphe courant (pas de nouveaux paragraphes).

=== BONNES PRATIQUES (recommandations) ===
PREFERE: COMPUTE ROUNDED au lieu de FUNCTION ROUND (plus simple).
PREFERE: Pas de END-COMPUTE (pas necessaire en COBOL, juste COMPUTE suffit).
AUTORISE mais moins bien: FUNCTION ROUND(...) est valide mais verbose.

=== FORMAT DE SORTIE ===
JSON uniquement, pas d'espaces en debut de ligne (l'indentation sera ajoutee plus tard).
Format: ["instruction 1", "instruction 2", ...]
Les steps doivent etre exploitables par un generateur COBOL.

=== PRINCIPE DE MINIMALISME ===
Genere le minimum d'instructions necessaires pour satisfaire les exigences.
Evite les variables intermediaires inutiles.
Privilegie les COMPUTE directs plutot que MOVE + ADD + MOVE.

=== FONCTIONS INTRINSÈQUES GNUCOBOL (CRITIQUE) ===
GnuCOBOL supporte un ensemble LIMITÉ de fonctions intrinsèques.

FONCTIONS DISPONIBLES (utilise UNIQUEMENT ces fonctions):
- FUNCTION INTEGER(x)      : Partie entière (tronque vers zéro)
- FUNCTION ANINT(x)        : Arrondi au plus proche
- FUNCTION MOD(x, y)       : Modulo
- FUNCTION MAX(x, y, ...)  : Maximum
- FUNCTION MIN(x, y, ...)  : Minimum
- FUNCTION ABS(x)          : Valeur absolue
- FUNCTION LENGTH(x)       : Longueur chaîne
- FUNCTION UPPER-CASE(x)   : Majuscules
- FUNCTION LOWER-CASE(x)   : Minuscules
- FUNCTION TRIM(x)         : Supprimer espaces
- FUNCTION CURRENT-DATE    : Date/heure système
- FUNCTION WHEN-COMPILED   : Date compilation
- FUNCTION NUMVAL(x)       : Convertir string en numérique

FONCTIONS NON DISPONIBLES (N'EXISTENT PAS):
❌ FUNCTION CEILING(x)  : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION CEIL(x)     : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION FLOOR(x)    : N'existe pas! Utilise INTEGER(x) à la place
❌ FUNCTION ROUND(x, n) : N'existe pas! Utilise COMPUTE ... ROUNDED à la place
❌ FUNCTION SQRT(x)     : N'existe pas!
❌ FUNCTION POW(x, y)   : N'existe pas!
❌ FUNCTION EXP(x)      : N'existe pas!
❌ FUNCTION LOG(x)      : N'existe pas!
❌ IF var NUMERIC = FALSE : N'existe pas! Utilise IF var IS NOT NUMERIC à la place

ARRONDI SUPÉRIEUR (équivalent CEILING):
Pour arrondir au supérieur, utilise cette technique:
  COMPUTE result = FUNCTION INTEGER(value + 0.999)

EXEMPLE CEILING:
  value = 5.2  → FUNCTION INTEGER(5.2 + 0.999) = INTEGER(6.199) = 6  ✓
  value = 5.0  → FUNCTION INTEGER(5.0 + 0.999) = INTEGER(5.999) = 5  ✓
  value = -3.5 → FUNCTION INTEGER(-3.5 + 0.999) = INTEGER(-2.501) = -2  ✓

ARRONDI STANDARD:
Préfère toujours COMPUTE ... ROUNDED au lieu de FUNCTION:
  ✅ CORRECT:   COMPUTE result ROUNDED = value1 * value2
  ❌ INTERDIT:  COMPUTE result = FUNCTION ROUND(value1 * value2)

VALIDATION NUMERIC:
Utilise IS NUMERIC ou IS NOT NUMERIC pour tester si un champ alphanumérique contient des chiffres:
  ✅ CORRECT:   IF var IS NUMERIC THEN ...
  ✅ CORRECT:   IF var IS NOT NUMERIC THEN ...
  ❌ INTERDIT:  IF var NUMERIC = FALSE ...

IMPORTANT: Si tu dois arrondir, utilise COMPUTE ROUNDED, PAS FUNCTION ROUND.

ERREUR DE COMPILATION SI TU UTILISES UNE FONCTION INEXISTANTE:
Si tu génères FUNCTION CEILING, CEIL, FLOOR, ROUND, SQRT, POW, etc.,
le compilateur GnuCOBOL retournera: "erreur : FUNCTION « XXX » inconnue"
et la compilation ÉCHOUERA.


INTERDIT: SET EOF-REACHED TO FALSE (cause erreur compilation, utilise MOVE 'N' TO END-OF-FILE)
INTERDIT: SET NOT-EOF TO FALSE (cause erreur compilation, utilise MOVE 'N' TO END-OF-FILE)

=== CONTEXTE ===
Programme: PARTICIPATION-LOGIC
Couche: logic
Entite: PARTICIPATION
Fonction: MAIN-PROCESS (required=True)
Description: Boucle principale du batch: lit les participations via la DAL, controle le mode transport, sauvegarde et affiche chaque participation.

=== SEPARATION DES COUCHES (CRITIQUE) ===
COUCHE LOGIC: Tu orchestres les appels DAL et BUSINESS.
- AUTORISE: PERFORM, CALL programmes, IF/ELSE pour flux
- INTERDIT: SQL direct, DISPLAY (utilise BUSINESS pour affichage)
- SCOPE: Boucles, conditions, orchestration uniquement

FLOW TEMPLATE STRICT (OBLIGATOIRE pour MAIN-PROCESS):
Tu DOIS generer EXACTEMENT ce flow (ne pas inventer):

NOTE: Les '...' dans les CALL ci-dessous signifient 'complete avec TOUS les parametres
      listes dans l'interface du programme' (voir section CALL TARGETS ci-dessous).

1. DISPLAY bandeau de debut
2. MOVE 'READ' TO OPERATION
3. CALL 'PARTICIPATION-DAL-DB' USING OPERATION END-OF-FILE ...
4. PERFORM UNTIL EOF-REACHED
     - Incrementer compteur (ADD 1 TO WS-COUNT)
     - PERFORM fonction calcul metier (ex: CALCULATE-NET)
     - MOVE 'SAVE' TO OPERATION
     - CALL 'PARTICIPATION-DAL-DB' USING OPERATION ...
     - CALL 'PARTICIPATION-BUSINESS' USING ... (pour affichage)
     - MOVE 'READ' TO OPERATION
     - CALL 'PARTICIPATION-DAL-DB' USING OPERATION ...
   END-PERFORM
5. MOVE 'END ' TO OPERATION (avec espace)
6. CALL 'PARTICIPATION-DAL-DB' USING OPERATION ...
7. DISPLAY bandeau de fin + compteur
8. STOP RUN

IMPORTANT: Ne PAS faire PERFORM DAL-xxx, toujours CALL le programme.
IMPORTANT: Chaque CALL doit inclure TOUS les parametres de l'interface (pas juste OPERATION).

=== POLITIQUE COMMIT POUR MAIN-PROCESS (CRITIQUE) ===
❌ INTERDIT: EXEC SQL COMMIT END-EXEC

Raison: cursor_commit_policy = no_commit_while_open
Cette fonction fait partie du traitement (READ/SAVE/UPDATE/etc.).
COMMIT fermerait le curseur et causerait SQLCODE=-400 sur le prochain FETCH.

✅ UTILISE A LA PLACE:
  - Pour erreurs: EXEC SQL ROLLBACK END-EXEC
  - Pour success: NE RIEN FAIRE (le COMMIT sera fait dans la fonction END)

IMPORTANT: Si tu generes 'EXEC SQL COMMIT END-EXEC' dans MAIN-PROCESS,
le programme plantera apres le premier enregistrement avec SQLCODE=-400.


=== CALL TARGETS AUTORISES ===
Programmes COBOL:
  - ACTIVITE-BUSINESS
    Interface: CALL 'ACTIVITE-BUSINESS' USING LK-ACTIVITE.
    Parametres USING (dans l'ordre):
      LK-ACTIVITE [groupe ACTIVITE] (in)

  - ACTIVITE-DAL-DB
    Interface: CALL 'ACTIVITE-DAL-DB' USING OPERATION, END-OF-FILE, ACTIVITE.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-ACTIVITE [groupe ACTIVITE] (inout)

  - ACTIVITE-LOGIC
  - ANTENNE-BUSINESS
    Interface: CALL 'ANTENNE-BUSINESS' USING LK-ANTENNE.
    Parametres USING (dans l'ordre):
      LK-ANTENNE [groupe ANTENNE] (in)

  - ANTENNE-DAL-DB
    Interface: CALL 'ANTENNE-DAL-DB' USING OPERATION, END-OF-FILE, ANTENNE.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-ANTENNE [groupe ANTENNE] (inout)

  - ANTENNE-LOGIC
  - HEBERGEMENT-BUSINESS
    Interface: CALL 'HEBERGEMENT-BUSINESS' USING LK-HEBERGEMENT.
    Parametres USING (dans l'ordre):
      LK-HEBERGEMENT [groupe HEBERGEMENT] (in)

  - HEBERGEMENT-DAL-DB
    Interface: CALL 'HEBERGEMENT-DAL-DB' USING OPERATION, END-OF-FILE, HEBERGEMENT.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-HEBERGEMENT [groupe HEBERGEMENT] (inout)

  - HEBERGEMENT-LOGIC
  - PARTICIPATION-BUSINESS
    Interface: CALL 'PARTICIPATION-BUSINESS' USING LK-PARTICIPATION.
    Parametres USING (dans l'ordre):
      LK-PARTICIPATION [groupe PARTICIPATION] (in)

  - PARTICIPATION-DAL-DB
    Interface: CALL 'PARTICIPATION-DAL-DB' USING OPERATION, END-OF-FILE, PARTICIPATION.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-PARTICIPATION [groupe PARTICIPATION] (inout)

  - REPAS-BUSINESS
    Interface: CALL 'REPAS-BUSINESS' USING LK-REPAS.
    Parametres USING (dans l'ordre):
      LK-REPAS [groupe REPAS] (in)

  - REPAS-DAL-DB
    Interface: CALL 'REPAS-DAL-DB' USING OPERATION, END-OF-FILE, REPAS.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-REPAS [groupe REPAS] (inout)

  - REPAS-LOGIC
  - UTILISATEUR-BUSINESS
    Interface: CALL 'UTILISATEUR-BUSINESS' USING LK-UTILISATEUR.
    Parametres USING (dans l'ordre):
      LK-UTILISATEUR [groupe UTILISATEUR] (in)

  - UTILISATEUR-DAL-DB
    Interface: CALL 'UTILISATEUR-DAL-DB' USING OPERATION, END-OF-FILE, UTILISATEUR.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-UTILISATEUR [groupe UTILISATEUR] (inout)

  - UTILISATEUR-LOGIC
IMPORTANT: N'utilise QUE les programmes listes ci-dessus. Inventer un CALL est INTERDIT.

CRITIQUE: Pour chaque CALL vers un programme, tu DOIS passer TOUS les parametres listes
dans 'Parametres USING (dans l'ordre)' ci-dessus, dans le MEME ORDRE, a CHAQUE appel.
Exemple: Si un programme attend 3 parametres (A, B, C), tu dois TOUJOURS faire:
  CALL 'PROGRAMME' USING A B C
JAMAIS juste 'CALL PROGRAMME USING A' ou 'CALL PROGRAMME USING A B'.
Les parametres sont OBLIGATOIRES et definis par la LINKAGE SECTION du programme appele.

=== PARAGRAPHES AUTORISES (PERFORM) ===
MAIN-PROCESS, CALCULATE-TRANSPORT
IMPORTANT: Utilise PERFORM uniquement vers les paragraphes listes ci-dessus.

=== ENTREES / SORTIES (noms COBOL uniquement) ===
Inputs: (aucun)
Outputs: (aucun)
Modifies: END-OF-FILE, WS-COUNT-ERROR, WS-COUNT-TOTAL

=== CHAMPS / STRUCTURE ===
PARTICIPATION-ID-ACTIVITE [9(9)] (INT, not null)
PARTICIPATION-ID-USER [9(9)] (INT, not null)
PARTICIPATION-MODE-TRANSPORT [S9(2)] (INT, not null)

=== WORKING-STORAGE (verbatim) ===
01  END-OF-FILE            PIC X VALUE 'N'.
88  EOF-REACHED        VALUE 'Y'.
88  NOT-EOF            VALUE 'N'.
77  OPERATION              PIC X(4).
77  WS-COUNT-TOTAL         PIC 9(6) VALUE 0.
77  WS-COUNT-ERROR         PIC 9(6) VALUE 0.
01  PARTICIPATION.
    05 PARTICIPATION-ID-ACTIVITE     PIC 9(9).
    05 PARTICIPATION-ID-USER         PIC 9(9).
    05 PARTICIPATION-MODE-TRANSPORT  PIC S9(2).

=== QUALIFICATION DES CHAMPS (CRITIQUE) ===
ATTENTION: Les structures suivantes contiennent des sous-champs: PARTICIPATION
REGLE ABSOLUE: Tous les sous-champs DOIVENT etre qualifies avec 'OF <structure>'.

Exemple pour PARTICIPATION:
  CORRECT:   MOVE 100 TO FIELD-NAME OF PARTICIPATION
  CORRECT:   COMPUTE RESULT OF PARTICIPATION = VALUE1 OF PARTICIPATION + VALUE2 OF PARTICIPATION
  INCORRECT: MOVE 100 TO FIELD-NAME  <-- ERREUR AMBIGUITE

IMPORTANT: Dans les regles metier ci-dessous, les noms de champs (ex: FEE-AMOUNT, AMOUNT-BRUT)
font reference aux sous-champs de PARTICIPATION.
Tu DOIS toujours qualifier ces champs avec 'OF <structure>' dans ton code COBOL.

=== MANIPULATION DES CONDITIONS 88-LEVEL (CRITIQUE) ===
ATTENTION: Cette section est CRITIQUE pour eviter des erreurs de compilation.
Les conditions 88-level ci-dessous ont des regles STRICTES en COBOL:

Conditions SANS clause FALSE (INTERDIT d'utiliser SET TO FALSE):

  - EOF-REACHED (parent: END-OF-FILE, VALUE 'Y', PAS de clause FALSE)
    Pour activer  : SET EOF-REACHED TO TRUE
    Pour desactiver: MOVE 'N' TO END-OF-FILE  <-- UTILISE CECI, PAS SET TO FALSE

  - NOT-EOF (parent: END-OF-FILE, VALUE 'N', PAS de clause FALSE)
    Pour activer  : SET NOT-EOF TO TRUE
    Pour desactiver: MOVE 'N' TO END-OF-FILE  <-- UTILISE CECI, PAS SET TO FALSE

EXEMPLES CONCRETS POUR CE PROGRAMME:

  EXEMPLE CORRECT (utilise MOVE pour desactiver):
    IF EOF-REACHED
        EXEC SQL CLOSE C_EMP END-EXEC
        MOVE 'N' TO END-OF-FILE  <-- CORRECT
    END-IF

  EXEMPLE INCORRECT (cause une erreur de compilation):
    IF EOF-REACHED
        EXEC SQL CLOSE C_EMP END-EXEC
        SET EOF-REACHED TO FALSE  <-- ERREUR! 'le champ n'a pas une clause FALSE'
    END-IF

RAPPEL CRITIQUE:
  - JAMAIS: SET EOF-REACHED TO FALSE  (provoque: 'erreur: le champ n'a pas une clause FALSE')
  - TOUJOURS: MOVE 'N' TO END-OF-FILE  (pour desactiver la condition)

LISTE COMPLETE DES DESACTIVATIONS REQUISES:
  - Pour desactiver EOF-REACHED: MOVE 'N' TO END-OF-FILE
  - Pour desactiver NOT-EOF: MOVE 'N' TO END-OF-FILE

=== SQL ACTIONS (ordre obligatoire) ===
(aucune)

=== SQL (si applicable) ===
(aucun)

=== DISPLAY SPEC (structure) ===
(aucune)

=== DISPLAY LINES (verbatim) ===
(aucune)

=== STATEMENTS OBLIGATOIRES ===
STOP RUN, CALL 'PARTICIPATION-DAL-DB' USING OPERATION, END-OF-FILE, PARTICIPATION, CALL 'PARTICIPATION-BUSINESS' USING PARTICIPATION

=== REGLES METIER (calculs et transformations) ===
Aucune
NOTE: Ces regles definissent les calculs a effectuer (ex: SALARY_NET = BRUT * 0.7).

=== REGLES DE VALIDATION (controles) ===
Aucune
NOTE: Ces regles definissent les controles a effectuer AVANT calcul.
Pour tester NULL/invalide en COBOL normal: utilise 'IS NOT NUMERIC' (pas 'IS NULL').
Exemple: IF SALARY-BRUT IS NOT NUMERIC → traiter comme invalide.


=== FLOW ===
Afficher le bandeau de debut
READ initial via DAL (OPERATION='READ')
Boucle jusqu'a EOF: incrementer WS-COUNT-TOTAL, CALCULATE-TRANSPORT, SAVE, BUSINESS display, READ suivant
Appeler DAL avec OPERATION='END '
Afficher le bandeau de fin avec les compteurs
STOP RUN

=== LOGGING ===
==========================================
DEBUT TRAITEMENT BATCH PARTICIPATIONS
==========================================
==========================================
FIN TRAITEMENT BATCH PARTICIPATIONS
Nombre participations traitees: 
Participations en erreur: 
==========================================
ANOMALIE: Mode transport invalide

=== FORMAT ===
Format FIXED: instructions commencent en colonne 8 (prefixe de 7 espaces).
Commentaires: '*' en colonne 7 (6 espaces + '*'), pas de commentaires '*>'.
Ne pas utiliser '>>SOURCE FORMAT FREE'.
PARAGRAPHES: Nom + point sur meme ligne. Format: MAIN-PROCESS. JAMAIS de point seul sur ligne.
En DATA DIVISION, chaque ligne 01/05/77/88 avec PIC ou VALUE se termine par un point.
Aucune ligne ne doit depasser 72 colonnes (format FIXED).
Si une instruction depasse 72 colonnes, la scinder sur plusieurs lignes.
Pour EXEC SQL FETCH/SELECT/UPDATE: mettre chaque variable hote sur sa propre ligne.
Ne pas mettre de point en fin de DISPLAY/GOBACK/STOP RUN/CALL/MOVE/IF (sauf EXEC SQL INCLUDE SQLCA END-EXEC.).
Utiliser des guillemets simples pour les messages DISPLAY.
Respecter l'ordre: IDENTIFICATION -> ENVIRONMENT -> DATA -> PROCEDURE.
Dans DATA: WORKING-STORAGE puis LINKAGE (si present).

=== IDENTIFIANTS AUTORISES ===
CALCULATE-TRANSPORT, END-OF-FILE, EOF-REACHED, MAIN-PROCESS, NOT-EOF, OPERATION, PARTICIPATION, PARTICIPATION-ID-ACTIVITE, PARTICIPATION-ID-USER, PARTICIPATION-MODE-TRANSPORT, SQLCA, SQLCODE, SQLERRMC, SQLSTATE, WS-COUNT-ERROR, WS-COUNT-TOTAL

=== SORTIE ATTENDUE ===
Retourne un JSON valide: ["step 1", "step 2", ...]