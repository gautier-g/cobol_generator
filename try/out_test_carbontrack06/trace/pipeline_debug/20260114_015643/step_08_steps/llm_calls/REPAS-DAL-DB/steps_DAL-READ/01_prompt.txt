!!! AVERTISSEMENT CRITIQUE - ERREUR DE COMPILATION FREQUENTE !!!

Ce programme contient des conditions 88-level SANS clause FALSE: WS-CONNECTED, WS-CURSOR-OPEN
Pour ces conditions, tu DOIS utiliser MOVE pour les desactiver:

  - Pour desactiver WS-CONNECTED: MOVE 'N' TO WS-CONNECTED-FLAG  (PAS 'SET WS-CONNECTED TO FALSE')
  - Pour desactiver WS-CURSOR-OPEN: MOVE 'N' TO WS-CURSOR-OPEN-FLAG  (PAS 'SET WS-CURSOR-OPEN TO FALSE')

Si tu utilises 'SET condition TO FALSE' sans clause FALSE declaree,
tu auras l'erreur: 'le champ n'a pas une clause FALSE' et la compilation ECHOUERA.
Voir section MANIPULATION DES CONDITIONS 88-LEVEL ci-dessous pour details.

======================================================================

Tu generes UNIQUEMENT une liste JSON de lignes de steps (liste de strings).
Pas de Markdown, pas d'explications, pas de code complet.
Chaque ligne doit tenir sur 72 colonnes max (format fixed).
Si une condition est longue, decoupe en IF imbriques ou EVALUATE.
Utilise END-IF/END-PERFORM/END-EVALUATE.

=== REGLES STRICTES (CRITIQUE) ===
1. Format JSON uniquement: ["step1", "step2", ...]
2. Pas d'indentation dans les steps (sera ajoutee plus tard)
3. Maximum 72 colonnes par ligne
4. N'invente JAMAIS de variables ou CALL targets
5. Utilise UNIQUEMENT les mots-cles COBOL minimaux (voir liste ci-dessous)

=== MOTS-CLES COBOL AUTORISES ===
IF, ELSE, END-IF, END-CALL, MOVE, COMPUTE, ROUNDED, ADD, SUBTRACT, MULTIPLY, DIVIDE,
DISPLAY, PERFORM, CALL, EVALUATE, WHEN, END-EVALUATE, END-PERFORM, FUNCTION,
EXEC SQL, END-EXEC, OPEN, FETCH, CLOSE, COMMIT, ROLLBACK,
IS NUMERIC, IS NOT NUMERIC, EQUAL, NOT EQUAL, GREATER, LESS, ZERO, OF, IN,
CONTINUE, GOBACK, STOP RUN, INITIALIZE, SET, ACCEPT

=== IDENTIFIANTS (CRITIQUE) ===
N'invente JAMAIS de variables: utilise UNIQUEMENT les identifiants de la liste 'IDENTIFIANTS AUTORISES'.
Chaque identifiant (WS-*, LK-*, nom de champ) doit exister dans cette liste.
Syntaxe structure: AUTORISE 'FIELD OF STRUCTURE' ou champ direct 'FIELD'.
INTERDIT: notation pointee (STRUCTURE.FIELD), identifiants non declares.
NOTE: Si tu vois SALARY-BRUT et EMPLOYEE dans la liste, tu peux utiliser:
  - 'SALARY-BRUT' seul (prefere)
  - 'SALARY-BRUT OF EMPLOYEE' (acceptable si necessaire pour clarte)

=== EXEMPLES VALIDES ===
  MOVE SALARY-BRUT TO WS-BRUT
  MOVE SALARY-BRUT OF EMPLOYEE TO WS-BRUT
  COMPUTE SALARY-NET ROUNDED = WS-BRUT * 0.7
  IF WS-BRUT IS NOT NUMERIC
  IF WS-TOTAL < 0
  DISPLAY 'Erreur: salaire invalide'
  CALL 'PROGRAM-NAME' USING PARAM1 PARAM2 PARAM3  <- Utilise TOUS les params de l'interface
  PERFORM CALCULATE-TOTAL
  END-IF

=== EXEMPLES INVALIDES ===
  MOVE EMPLOYEE.SALARY TO WS-TOTAL  <- INTERDIT (notation pointee)
  COMPUTE WS-NEW-VAR = 100  <- INTERDIT (WS-NEW-VAR non declare)
  IF SALARY IS NEGATIVE  <- INTERDIT (n'existe pas, utilise: IF SALARY < 0)
  IF SALARY IS NOT NULL  <- INTERDIT hors SQL (utilise IS NOT NUMERIC)
  CALL 'INVENTED-PROGRAM'  <- INTERDIT (pas dans liste CALL TARGETS)
  CALL 'PROGRAM' USING PARAM1  <- INTERDIT si l'interface definit 3 params (manque PARAM2, PARAM3)
  PERFORM DAL-SAVE dans LOGIC  <- INTERDIT (CALL le programme DAL, pas PERFORM)

=== INTERDICTIONS (CRITIQUE) ===
INTERDIT: divisions/sections, PROGRAM-ID, paragraphes (labels avec point), DATA/WS/LINKAGE.
INTERDIT: ligne avec un seul point.
INTERDIT: identifiants non declares ou inventes.
INTERDIT: IS NEGATIVE, IS POSITIVE (n'existent pas en COBOL, utilise < 0, > 0).
INTERDIT: IS NULL hors EXEC SQL (dans COBOL normal, utilise IS NOT NUMERIC).
INTERDIT: CALL vers programme non liste dans CALL TARGETS.
SCOPE: uniquement les instructions du paragraphe courant (pas de nouveaux paragraphes).

=== BONNES PRATIQUES (recommandations) ===
PREFERE: COMPUTE ROUNDED au lieu de FUNCTION ROUND (plus simple).
PREFERE: Pas de END-COMPUTE (pas necessaire en COBOL, juste COMPUTE suffit).
AUTORISE mais moins bien: FUNCTION ROUND(...) est valide mais verbose.

=== FORMAT DE SORTIE ===
JSON uniquement, pas d'espaces en debut de ligne (l'indentation sera ajoutee plus tard).
Format: ["instruction 1", "instruction 2", ...]
Les steps doivent etre exploitables par un generateur COBOL.

=== PRINCIPE DE MINIMALISME ===
Genere le minimum d'instructions necessaires pour satisfaire les exigences.
Evite les variables intermediaires inutiles.
Privilegie les COMPUTE directs plutot que MOVE + ADD + MOVE.

=== FONCTIONS INTRINSÈQUES GNUCOBOL (CRITIQUE) ===
GnuCOBOL supporte un ensemble LIMITÉ de fonctions intrinsèques.

FONCTIONS DISPONIBLES (utilise UNIQUEMENT ces fonctions):
- FUNCTION INTEGER(x)      : Partie entière (tronque vers zéro)
- FUNCTION ANINT(x)        : Arrondi au plus proche
- FUNCTION MOD(x, y)       : Modulo
- FUNCTION MAX(x, y, ...)  : Maximum
- FUNCTION MIN(x, y, ...)  : Minimum
- FUNCTION ABS(x)          : Valeur absolue
- FUNCTION LENGTH(x)       : Longueur chaîne
- FUNCTION UPPER-CASE(x)   : Majuscules
- FUNCTION LOWER-CASE(x)   : Minuscules
- FUNCTION TRIM(x)         : Supprimer espaces
- FUNCTION CURRENT-DATE    : Date/heure système
- FUNCTION WHEN-COMPILED   : Date compilation
- FUNCTION NUMVAL(x)       : Convertir string en numérique

FONCTIONS NON DISPONIBLES (N'EXISTENT PAS):
❌ FUNCTION CEILING(x)  : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION CEIL(x)     : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION FLOOR(x)    : N'existe pas! Utilise INTEGER(x) à la place
❌ FUNCTION ROUND(x, n) : N'existe pas! Utilise COMPUTE ... ROUNDED à la place
❌ FUNCTION SQRT(x)     : N'existe pas!
❌ FUNCTION POW(x, y)   : N'existe pas!
❌ FUNCTION EXP(x)      : N'existe pas!
❌ FUNCTION LOG(x)      : N'existe pas!
❌ IF var NUMERIC = FALSE : N'existe pas! Utilise IF var IS NOT NUMERIC à la place

ARRONDI SUPÉRIEUR (équivalent CEILING):
Pour arrondir au supérieur, utilise cette technique:
  COMPUTE result = FUNCTION INTEGER(value + 0.999)

EXEMPLE CEILING:
  value = 5.2  → FUNCTION INTEGER(5.2 + 0.999) = INTEGER(6.199) = 6  ✓
  value = 5.0  → FUNCTION INTEGER(5.0 + 0.999) = INTEGER(5.999) = 5  ✓
  value = -3.5 → FUNCTION INTEGER(-3.5 + 0.999) = INTEGER(-2.501) = -2  ✓

ARRONDI STANDARD:
Préfère toujours COMPUTE ... ROUNDED au lieu de FUNCTION:
  ✅ CORRECT:   COMPUTE result ROUNDED = value1 * value2
  ❌ INTERDIT:  COMPUTE result = FUNCTION ROUND(value1 * value2)

VALIDATION NUMERIC:
Utilise IS NUMERIC ou IS NOT NUMERIC pour tester si un champ alphanumérique contient des chiffres:
  ✅ CORRECT:   IF var IS NUMERIC THEN ...
  ✅ CORRECT:   IF var IS NOT NUMERIC THEN ...
  ❌ INTERDIT:  IF var NUMERIC = FALSE ...

IMPORTANT: Si tu dois arrondir, utilise COMPUTE ROUNDED, PAS FUNCTION ROUND.

ERREUR DE COMPILATION SI TU UTILISES UNE FONCTION INEXISTANTE:
Si tu génères FUNCTION CEILING, CEIL, FLOOR, ROUND, SQRT, POW, etc.,
le compilateur GnuCOBOL retournera: "erreur : FUNCTION « XXX » inconnue"
et la compilation ÉCHOUERA.



=== SQL EMBARQUÉ OCESQL (CRITIQUE - PRIORITÉ ABSOLUE) ===
Contexte: workflow OCESQL en mode précompilation (ex: `ocesql file.cbl file.cob`).
Le fichier source `.cbl` DOIT contenir du SQL EMBARQUÉ standard (`EXEC SQL ... END-EXEC`).
Le précompilateur traduit automatiquement les blocs `EXEC SQL` en appels runtime (ex: `CALL 'OCESQLExec' USING SQLCA ...`).
Donc: NE PAS écrire d'appels OCESQL* dans le `.cbl`.

1) RÈGLES ABSOLUES (à respecter même si des specs mentionnent OCESQL*)
INTERDIT dans le `.cbl` source:
❌ CALL 'OCESQLStartSQL' ...
❌ CALL 'OCESQLConnect' ...
❌ CALL 'OCESQLEndSQL' ...
❌ CALL 'OCESQLExec' ...
❌ CALL 'OCESQLDisconnect' ...
❌ EXEC SQL CALL OCESQL... END-EXEC

Toujours utiliser uniquement:
✅ EXEC SQL <statement SQL standard> END-EXEC

2) RÈGLES DE FORME (évite les sorties qui compilent mais ne marchent pas)
- Chaque bloc SQL DOIT être complet et fermé:
  ✅ commence par `EXEC SQL`
  ✅ se termine par `END-EXEC` sur la même instruction
  ❌ INTERDIT: une ligne `EXEC SQL` seule (sans statement)
  ❌ INTERDIT: un `DECLARE ...` séparé sans `EXEC SQL ... END-EXEC` complet

- Ne jamais dupliquer SQLCA:
  ✅ `EXEC SQL INCLUDE SQLCA END-EXEC.` doit exister UNE seule fois en WORKING-STORAGE
  ❌ ne jamais générer `INCLUDE SQLCA` dans PROCEDURE / steps

3) CONNEXION / COMMIT / DÉCONNEXION (formes attendues)
CONNEXION:
✅ EXEC SQL CONNECT :USER IDENTIFIED BY :PASSWORD USING :DBNAME END-EXEC.

COMMIT:
✅ EXEC SQL COMMIT END-EXEC.

DÉCONNEXION:
✅ EXEC SQL DISCONNECT ALL END-EXEC.

IMPORTANT (HOST VARIABLES pour CONNECT):
Les host variables SQL `:var` doivent être des champs ÉLÉMENTAIRES COBOL.
Si un identifiant est un GROUPE (ex: `WS-DB-USER`) et qu'il existe un champ `WS-DB-USER-TEXT`,
ALORS utiliser `:WS-DB-USER-TEXT` (et idem pour PASSWORD/DBNAME).

✅ CORRECT (utilise les champs élémentaires *-TEXT):
    EXEC SQL CONNECT :WS-DB-USER-TEXT IDENTIFIED BY :WS-DB-PASSWORD-TEXT
        USING :WS-DB-NAME-TEXT
    END-EXEC

❌ FAUX (utilise un GROUPE comme host variable):
    EXEC SQL CONNECT :WS-DB-USER IDENTIFIED BY :WS-DB-PASSWORD USING :WS-DB-NAME END-EXEC

4) CURSEURS (ordre obligatoire + séquence complète)
RÈGLE: l'ordre est STRICT et la séquence doit être cohérente dans le même paragraphe/flux.
Tu ne peux pas OPEN/FETCH un curseur non déclaré.

✅ ÉTAPE 1 — DECLARE (AVANT toute utilisation, généralement en début de paragraphe ou section dédiée):
    EXEC SQL DECLARE cursor-name CURSOR FOR
        SELECT col1, col2 FROM table
    END-EXEC

✅ ÉTAPE 2 — OPEN (APRÈS DECLARE):
    EXEC SQL OPEN cursor-name END-EXEC

✅ ÉTAPE 3 — FETCH (APRÈS OPEN):
    EXEC SQL FETCH cursor-name INTO :var1, :var2 END-EXEC

✅ ÉTAPE 4 — CLOSE (APRÈS FETCH et avant sortie du flux):
    EXEC SQL CLOSE cursor-name END-EXEC

INTERDIT / erreurs fréquentes:
❌ OPEN sans DECLARE
❌ DECLARE placé après OPEN (ou en fin de fichier)
❌ `EXEC SQL` isolé sans statement
❌ FETCH avant OPEN
❌ CLOSE avant OPEN/FETCH

5) RÈGLE ABSOLUE ANTI-TRAILING SPACES (données enum/status)
Les champs COBOL `PIC X(n)` sont space-padded. Si tu écris directement `:WS-STATUS` en base,
la base stocke souvent `OK       ` / `LOW       ` / `BLOCKED   ` au lieu de `OK` / `LOW` / `BLOCKED`.
Ça casse ensuite les comparaisons exactes (`WHERE status = 'OK'`) et les tests stricts.

Donc, pour les colonnes de type "enum/status/short string" (ex: risk_level, compliance_status, etc.),
tu DOIS normaliser côté SQL lors de l'UPDATE/INSERT (sans changer la valeur logique):

✅ CORRECT (normalisation côté SQL):
    EXEC SQL UPDATE OPERATION
        SET RISK_LEVEL = RTRIM(:WS-RISK-LEVEL),
            COMPLIANCE_STATUS = RTRIM(:WS-COMPLIANCE-STATUS)
        WHERE OP_ID = :WS-OP-ID
    END-EXEC

✅ Alternative acceptable (si RTRIM non souhaité):
    utiliser TRIM(:var) (TRIM = enlever espaces des deux côtés)

❌ FAUX (stocke la valeur paddée):
    EXEC SQL UPDATE OPERATION
        SET RISK_LEVEL = :WS-RISK-LEVEL
        WHERE OP_ID = :WS-OP-ID
    END-EXEC

6) CHECK ERREUR SQL (pattern attendu)
Après un CONNECT/UPDATE/INSERT/SELECT important, vérifier SQLCODE:

    IF SQLCODE NOT EQUAL ZERO
        DISPLAY 'ERREUR SQL: SQLCODE=' SQLCODE
        GOBACK
    END-IF

RAPPEL:
- Tu n'écris PAS les appels OCESQL* dans le `.cbl`.
- Tu écris du `EXEC SQL ... END-EXEC` standard.
- Host variables: champs élémentaires (préférer `*-TEXT` si un groupe existe).
- Curseurs: DECLARE → OPEN → FETCH → CLOSE, dans cet ordre strict.
- Enum/status: RTRIM/TRIM à l'écriture SQL pour éviter les espaces stockés.


INTERDIT: SET WS-CONNECTED TO FALSE (cause erreur compilation, utilise MOVE 'N' TO WS-CONNECTED-FLAG)
INTERDIT: SET WS-CURSOR-OPEN TO FALSE (cause erreur compilation, utilise MOVE 'N' TO WS-CURSOR-OPEN-FLAG)

=== CONTEXTE ===
Programme: REPAS-DAL-DB
Couche: dal
Entite: REPAS
Fonction: DAL-READ (required=True)
Description: Ouvre le curseur C_REP si necessaire, fait un FETCH et remplit la structure REPAS. Met END-OF-FILE a 'Y' en cas de fin de donnees ou d erreur.

=== SEPARATION DES COUCHES (CRITIQUE) ===
COUCHE DAL: Tu generes du code d'acces aux donnees UNIQUEMENT.
- AUTORISE: EXEC SQL, OPEN, FETCH, CLOSE, MOVE variables SQL
- INTERDIT: COMPUTE, calculs metier, logique business
- SCOPE: Lecture/ecriture base de donnees, pas de traitement
NOTE DAL: Tu DOIS respecter l'ordre des actions SQL ci-dessous.
Si 'declare_cursor' est present, DECLARE doit apparaitre avant OPEN.
Si 'open_cursor' est present, OPEN doit apparaitre avant FETCH.

=== POLITIQUE COMMIT POUR DAL-READ (CRITIQUE) ===
❌ INTERDIT: EXEC SQL COMMIT END-EXEC

Raison: cursor_commit_policy = no_commit_while_open
Cette fonction fait partie du traitement (READ/SAVE/UPDATE/etc.).
COMMIT fermerait le curseur et causerait SQLCODE=-400 sur le prochain FETCH.

✅ UTILISE A LA PLACE:
  - Pour erreurs: EXEC SQL ROLLBACK END-EXEC
  - Pour success: NE RIEN FAIRE (le COMMIT sera fait dans la fonction END)

IMPORTANT: Si tu generes 'EXEC SQL COMMIT END-EXEC' dans DAL-READ,
le programme plantera apres le premier enregistrement avec SQLCODE=-400.


=== CALL TARGETS AUTORISES ===
Programmes COBOL:
  - ACTIVITE-BUSINESS
    Interface: CALL 'ACTIVITE-BUSINESS' USING LK-ACTIVITE.
    Parametres USING (dans l'ordre):
      LK-ACTIVITE [groupe ACTIVITE] (in)

  - ACTIVITE-DAL-DB
    Interface: CALL 'ACTIVITE-DAL-DB' USING OPERATION, END-OF-FILE, ACTIVITE.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-ACTIVITE [groupe ACTIVITE] (inout)

  - ACTIVITE-LOGIC
  - ANTENNE-BUSINESS
    Interface: CALL 'ANTENNE-BUSINESS' USING LK-ANTENNE.
    Parametres USING (dans l'ordre):
      LK-ANTENNE [groupe ANTENNE] (in)

  - ANTENNE-DAL-DB
    Interface: CALL 'ANTENNE-DAL-DB' USING OPERATION, END-OF-FILE, ANTENNE.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-ANTENNE [groupe ANTENNE] (inout)

  - ANTENNE-LOGIC
  - HEBERGEMENT-BUSINESS
    Interface: CALL 'HEBERGEMENT-BUSINESS' USING LK-HEBERGEMENT.
    Parametres USING (dans l'ordre):
      LK-HEBERGEMENT [groupe HEBERGEMENT] (in)

  - HEBERGEMENT-DAL-DB
    Interface: CALL 'HEBERGEMENT-DAL-DB' USING OPERATION, END-OF-FILE, HEBERGEMENT.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-HEBERGEMENT [groupe HEBERGEMENT] (inout)

  - HEBERGEMENT-LOGIC
  - PARTICIPATION-BUSINESS
    Interface: CALL 'PARTICIPATION-BUSINESS' USING LK-PARTICIPATION.
    Parametres USING (dans l'ordre):
      LK-PARTICIPATION [groupe PARTICIPATION] (in)

  - PARTICIPATION-DAL-DB
    Interface: CALL 'PARTICIPATION-DAL-DB' USING OPERATION, END-OF-FILE, PARTICIPATION.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-PARTICIPATION [groupe PARTICIPATION] (inout)

  - PARTICIPATION-LOGIC
  - REPAS-BUSINESS
    Interface: CALL 'REPAS-BUSINESS' USING LK-REPAS.
    Parametres USING (dans l'ordre):
      LK-REPAS [groupe REPAS] (in)

  - REPAS-LOGIC
  - UTILISATEUR-BUSINESS
    Interface: CALL 'UTILISATEUR-BUSINESS' USING LK-UTILISATEUR.
    Parametres USING (dans l'ordre):
      LK-UTILISATEUR [groupe UTILISATEUR] (in)

  - UTILISATEUR-DAL-DB
    Interface: CALL 'UTILISATEUR-DAL-DB' USING OPERATION, END-OF-FILE, UTILISATEUR.
    Parametres USING (dans l'ordre):
      LK-OPERATION [X(4)] (in)
      LK-END-OF-FILE [X] (inout)
      LK-UTILISATEUR [groupe UTILISATEUR] (inout)

  - UTILISATEUR-LOGIC
IMPORTANT: N'utilise QUE les programmes listes ci-dessus. Inventer un CALL est INTERDIT.

CRITIQUE: Pour chaque CALL vers un programme, tu DOIS passer TOUS les parametres listes
dans 'Parametres USING (dans l'ordre)' ci-dessus, dans le MEME ORDRE, a CHAQUE appel.
Exemple: Si un programme attend 3 parametres (A, B, C), tu dois TOUJOURS faire:
  CALL 'PROGRAMME' USING A B C
JAMAIS juste 'CALL PROGRAMME USING A' ou 'CALL PROGRAMME USING A B'.
Les parametres sont OBLIGATOIRES et definis par la LINKAGE SECTION du programme appele.

=== PARAGRAPHES AUTORISES (PERFORM) ===
DAL-CONNECT, DAL-SET-ENV, DAL-READ, DAL-SAVE, DAL-END
IMPORTANT: Utilise PERFORM uniquement vers les paragraphes listes ci-dessus.

=== ENTREES / SORTIES (noms COBOL uniquement) ===
Inputs: (aucun)
Outputs: END-OF-FILE, SQLCODE
Modifies: END-OF-FILE, SQLCODE, WS-CONNECTED, WS-CURSOR-OPEN

=== CHAMPS / STRUCTURE ===
REPAS-ID [9(9)] (INT, not null)
REPAS-ID-ACTIVITE [9(9)] (INT, not null)
REPAS-TYPE [9(2)] (INT, not null)
REPAS-NBREPAS [S9(5)] (INT, not null)

=== WORKING-STORAGE (verbatim) ===
EXEC SQL INCLUDE SQLCA END-EXEC.
01  WS-CONNECTED-FLAG      PIC X VALUE 'N'.
88  WS-CONNECTED           VALUE 'Y'.
01  WS-CURSOR-OPEN-FLAG    PIC X VALUE 'N'.
88  WS-CURSOR-OPEN         VALUE 'Y'.
01  WS-REPAS-ID            PIC 9(9).
01  WS-REPAS-ID-ACTIVITE   PIC 9(9).
01  WS-REPAS-TYPE          PIC 9(2).
01  WS-REPAS-NBREPAS       PIC S9(5).
01  WS-DB-NAME.
05  WS-DB-NAME-TEXT     PIC X(13) VALUE 'carbontrackdb'.
05  WS-DB-NAME-TERM     PIC X VALUE X'00'.
01  WS-DB-USER.
05  WS-DB-USER-TEXT     PIC X(10) VALUE 'carbonuser'.
05  WS-DB-USER-TERM     PIC X VALUE X'00'.
01  WS-DB-PASSWORD.
05  WS-DB-PASSWORD-TEXT PIC X(9) VALUE 'CARBONPWD'.
05  WS-DB-PASSWORD-TERM PIC X VALUE X'00'.
01  WS-DB-NAME-LEN         PIC S9(4) COMP-5 VALUE 13.
01  WS-DB-USER-LEN         PIC S9(4) COMP-5 VALUE 10.
01  WS-DB-PASSWORD-LEN     PIC S9(4) COMP-5 VALUE 9.
01  WS-PGHOST-NAME         PIC X(6) VALUE 'PGHOST'.
01  WS-PGHOST-VALUE        PIC X(64) VALUE 'localhost'.
01  WS-PGPORT-NAME         PIC X(6) VALUE 'PGPORT'.
01  WS-PGPORT-VALUE        PIC X(5) VALUE '5432'.
01  WS-PGUSER-NAME         PIC X(6) VALUE 'PGUSER'.
01  WS-PGUSER-VALUE        PIC X(64) VALUE 'carbonuser'.
01  WS-PGPASSWORD-NAME     PIC X(10) VALUE 'PGPASSWORD'.
01  WS-PGPASSWORD-VALUE    PIC X(64) VALUE 'CARBONPWD'.
01  WS-PGDATABASE-NAME     PIC X(10) VALUE 'PGDATABASE'.
01  WS-PGDATABASE-VALUE    PIC X(64) VALUE 'carbontrackdb'.

=== QUALIFICATION DES CHAMPS (CRITIQUE) ===
ATTENTION: Les structures suivantes contiennent des sous-champs: WS-DB-NAME, WS-DB-USER, WS-DB-PASSWORD
REGLE ABSOLUE: Tous les sous-champs DOIVENT etre qualifies avec 'OF <structure>'.

Exemple pour WS-DB-NAME:
  CORRECT:   MOVE 100 TO FIELD-NAME OF WS-DB-NAME
  CORRECT:   COMPUTE RESULT OF WS-DB-NAME = VALUE1 OF WS-DB-NAME + VALUE2 OF WS-DB-NAME
  INCORRECT: MOVE 100 TO FIELD-NAME  <-- ERREUR AMBIGUITE

Exemple pour WS-DB-USER:
  CORRECT:   MOVE 100 TO FIELD-NAME OF WS-DB-USER
  CORRECT:   COMPUTE RESULT OF WS-DB-USER = VALUE1 OF WS-DB-USER + VALUE2 OF WS-DB-USER
  INCORRECT: MOVE 100 TO FIELD-NAME  <-- ERREUR AMBIGUITE

Exemple pour WS-DB-PASSWORD:
  CORRECT:   MOVE 100 TO FIELD-NAME OF WS-DB-PASSWORD
  CORRECT:   COMPUTE RESULT OF WS-DB-PASSWORD = VALUE1 OF WS-DB-PASSWORD + VALUE2 OF WS-DB-PASSWORD
  INCORRECT: MOVE 100 TO FIELD-NAME  <-- ERREUR AMBIGUITE

IMPORTANT: Dans les regles metier ci-dessous, les noms de champs (ex: FEE-AMOUNT, AMOUNT-BRUT)
font reference aux sous-champs de la structure appropriee.
Tu DOIS toujours qualifier ces champs avec 'OF <structure>' dans ton code COBOL.

=== MANIPULATION DES CONDITIONS 88-LEVEL (CRITIQUE) ===
ATTENTION: Cette section est CRITIQUE pour eviter des erreurs de compilation.
Les conditions 88-level ci-dessous ont des regles STRICTES en COBOL:

Conditions SANS clause FALSE (INTERDIT d'utiliser SET TO FALSE):

  - WS-CONNECTED (parent: WS-CONNECTED-FLAG, VALUE 'Y', PAS de clause FALSE)
    Pour activer  : SET WS-CONNECTED TO TRUE
    Pour desactiver: MOVE 'N' TO WS-CONNECTED-FLAG  <-- UTILISE CECI, PAS SET TO FALSE

  - WS-CURSOR-OPEN (parent: WS-CURSOR-OPEN-FLAG, VALUE 'Y', PAS de clause FALSE)
    Pour activer  : SET WS-CURSOR-OPEN TO TRUE
    Pour desactiver: MOVE 'N' TO WS-CURSOR-OPEN-FLAG  <-- UTILISE CECI, PAS SET TO FALSE

EXEMPLES CONCRETS POUR CE PROGRAMME:

  EXEMPLE CORRECT (utilise MOVE pour desactiver):
    IF WS-CONNECTED
        EXEC SQL CLOSE C_EMP END-EXEC
        MOVE 'N' TO WS-CONNECTED-FLAG  <-- CORRECT
    END-IF

  EXEMPLE INCORRECT (cause une erreur de compilation):
    IF WS-CONNECTED
        EXEC SQL CLOSE C_EMP END-EXEC
        SET WS-CONNECTED TO FALSE  <-- ERREUR! 'le champ n'a pas une clause FALSE'
    END-IF

RAPPEL CRITIQUE:
  - JAMAIS: SET WS-CONNECTED TO FALSE  (provoque: 'erreur: le champ n'a pas une clause FALSE')
  - TOUJOURS: MOVE 'N' TO WS-CONNECTED-FLAG  (pour desactiver la condition)

LISTE COMPLETE DES DESACTIVATIONS REQUISES:
  - Pour desactiver WS-CONNECTED: MOVE 'N' TO WS-CONNECTED-FLAG
  - Pour desactiver WS-CURSOR-OPEN: MOVE 'N' TO WS-CURSOR-OPEN-FLAG

=== LINKAGE PARAMETERS ===
LK-OPERATION [X(4)] (in)
LK-END-OF-FILE [X] (inout)
LK-REPAS [groupe REPAS] (inout)
IMPORTANT: Utilise ces noms exacts dans USING et dans les steps.

=== SQL ACTIONS (ordre obligatoire) ===
declare_cursor -> open_cursor -> fetch_cursor -> check_sqlcode -> map_to_linkage -> set_eof

=== SQL (si applicable) ===
declare_cursor: DECLARE C_REP CURSOR FOR
SELECT REPAS_ID, REPAS_ID_ACTIVITE, REPAS_TYPE, REPAS_NBREPAS
FROM REPAS
ORDER BY REPAS_ID

fetch_into: FETCH C_REP INTO :WS-REPAS-ID, :WS-REPAS-ID-ACTIVITE, :WS-REPAS-TYPE, :WS-REPAS-NBREPAS
open_cursor: OPEN C_REP

=== DISPLAY SPEC (structure) ===
(aucune)

=== DISPLAY LINES (verbatim) ===
(aucune)

=== STATEMENTS OBLIGATOIRES ===
GOBACK, END-CALL, BY REFERENCE, BY VALUE, EXIT PARAGRAPH, EVALUATE SQLCODE

=== REGLES METIER (calculs et transformations) ===
[R4] Toutes les operations BD sont realisees en COBOL embarque SQL PostgreSQL (OCESQL).
NOTE: Ces regles definissent les calculs a effectuer (ex: SALARY_NET = BRUT * 0.7).

=== REGLES DE VALIDATION (controles) ===
Aucune
NOTE: Ces regles definissent les controles a effectuer AVANT calcul.
Pour tester NULL/invalide en COBOL normal: utilise 'IS NOT NUMERIC' (pas 'IS NULL').
Exemple: IF SALARY-BRUT IS NOT NUMERIC → traiter comme invalide.


=== FLOW ===
MAIN-ENTRY: IF LK-OPERATION NOT = 'END ' THEN PERFORM DAL-CONNECT; IF NOT WS-CONNECTED THEN MOVE 'Y' TO LK-END-OF-FILE, GOBACK; END-IF; END-IF
EVALUATE LK-OPERATION: READ->DAL-READ, SAVE->DAL-SAVE, END->DAL-END, OTHER->DISPLAY erreur
GOBACK apres EVALUATE
DAL-READ: ouverture curseur paresseuse, FETCH, mise a jour EOF
DAL-SAVE: UPDATE REPAS_NBREPAS
DAL-END: CLOSE cursor, COMMIT, DISCONNECT, reset flags

=== LOGGING ===
Connexion DB reussie: carbontrackdb
ERREUR CONNECT: SQLCODE=
SQLSTATE=
SQLERRMC=
Curseur C_REP ouvert
ERREUR OPEN: SQLCODE=
ERREUR FETCH: SQLCODE=
ERREUR UPDATE: SQLCODE=
ERREUR CLOSE: SQLCODE=
ERREUR COMMIT: SQLCODE=
ERREUR DISCONNECT: SQLCODE=
ERREUR: Operation inconnue: 
Fermeture connexion

=== FORMAT ===
Format FIXED: instructions commencent en colonne 8 (prefixe de 7 espaces).
Commentaires: '*' en colonne 7 (6 espaces + '*'), pas de commentaires '*>'.
Ne pas utiliser '>>SOURCE FORMAT FREE'.
PARAGRAPHES: Nom + point sur meme ligne. Format: MAIN-PROCESS. JAMAIS de point seul sur ligne.
En DATA DIVISION, chaque ligne 01/05/77/88 avec PIC ou VALUE se termine par un point.
Aucune ligne ne doit depasser 72 colonnes (format FIXED).
Si une instruction depasse 72 colonnes, la scinder sur plusieurs lignes.
Pour EXEC SQL FETCH/SELECT/UPDATE: mettre chaque variable hote sur sa propre ligne.
Ne pas mettre de point en fin de DISPLAY/GOBACK/STOP RUN/CALL/MOVE/IF (sauf EXEC SQL INCLUDE SQLCA END-EXEC.).
Utiliser des guillemets simples pour les messages DISPLAY.
Respecter l'ordre: IDENTIFICATION -> ENVIRONMENT -> DATA -> PROCEDURE.
Dans DATA: WORKING-STORAGE puis LINKAGE (si present).

=== IDENTIFIANTS AUTORISES ===
DAL-CONNECT, DAL-END, DAL-READ, DAL-SAVE, DAL-SET-ENV, END-OF-FILE, LK-END-OF-FILE, LK-OPERATION, LK-REPAS, REPAS, REPAS-ID, REPAS-ID-ACTIVITE, REPAS-NBREPAS, REPAS-TYPE, SQLCA, SQLCODE, SQLERRMC, SQLSTATE, WS-CONNECTED, WS-CONNECTED-FLAG, WS-CURSOR-OPEN, WS-CURSOR-OPEN-FLAG, WS-DB-NAME, WS-DB-NAME-LEN, WS-DB-NAME-TERM, WS-DB-NAME-TEXT, WS-DB-PASSWORD, WS-DB-PASSWORD-LEN, WS-DB-PASSWORD-TERM, WS-DB-PASSWORD-TEXT, WS-DB-USER, WS-DB-USER-LEN, WS-DB-USER-TERM, WS-DB-USER-TEXT, WS-PGDATABASE-NAME, WS-PGDATABASE-VALUE, WS-PGHOST-NAME, WS-PGHOST-VALUE, WS-PGPASSWORD-NAME, WS-PGPASSWORD-VALUE, WS-PGPORT-NAME, WS-PGPORT-VALUE, WS-PGUSER-NAME, WS-PGUSER-VALUE, WS-REPAS-ID, WS-REPAS-ID-ACTIVITE, WS-REPAS-NBREPAS, WS-REPAS-TYPE

=== SORTIE ATTENDUE ===
Retourne un JSON valide: ["step 1", "step 2", ...]