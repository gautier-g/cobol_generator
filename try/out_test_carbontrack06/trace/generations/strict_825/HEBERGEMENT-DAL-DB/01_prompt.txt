Reponds uniquement avec du code COBOL compilable, sans Markdown ni texte autour.
La premiere ligne doit etre IDENTIFICATION DIVISION.
Un seul PROGRAM-ID, pas de sous-programmes.
Utilise strictement les identifiants, messages, SQL et sequences definis dans la spec.
N'invente aucune variable, paragraphe, message ou SQL.
Respecte exactement les listes de WORKING-STORAGE, LINKAGE et USING.
Toujours utiliser les terminateurs explicites END-IF / END-EVALUATE / END-PERFORM / END-EXEC.
Pas de GO TO, pas de logique DAL dans LOGIC, pas de SQL hors DAL.
Toute variable utilisee doit etre declaree (WORKING-STORAGE ou LINKAGE).
REGLE ABSOLUE PARAGRAPHES: Le nom ET le point sur la MEME ligne. Format: CALCULATE-FEES. JAMAIS de ligne avec juste un point apres.
REGLE ABSOLUE EXEC SQL INCLUDE: EXEC SQL INCLUDE SQLCA END-EXEC. (avec point final). Autres instructions COBOL sans point final.
REGLE ABSOLUE QUALIFICATION: Sous-champs avec OF obligatoire. Format: AMOUNT-BRUT OF OPERATION-REC.
Dans DATA DIVISION (WORKING-STORAGE/LINKAGE), toute ligne 01/05/77/88 avec PIC ou VALUE doit se terminer par un point. Regle non applicable en PROCEDURE DIVISION.

=== FONCTIONS INTRINSÈQUES GNUCOBOL (CRITIQUE) ===
GnuCOBOL supporte un ensemble LIMITÉ de fonctions intrinsèques.

FONCTIONS DISPONIBLES (utilise UNIQUEMENT ces fonctions):
- FUNCTION INTEGER(x)      : Partie entière (tronque vers zéro)
- FUNCTION ANINT(x)        : Arrondi au plus proche
- FUNCTION MOD(x, y)       : Modulo
- FUNCTION MAX(x, y, ...)  : Maximum
- FUNCTION MIN(x, y, ...)  : Minimum
- FUNCTION ABS(x)          : Valeur absolue
- FUNCTION LENGTH(x)       : Longueur chaîne
- FUNCTION UPPER-CASE(x)   : Majuscules
- FUNCTION LOWER-CASE(x)   : Minuscules
- FUNCTION TRIM(x)         : Supprimer espaces
- FUNCTION CURRENT-DATE    : Date/heure système
- FUNCTION WHEN-COMPILED   : Date compilation
- FUNCTION NUMVAL(x)       : Convertir string en numérique

FONCTIONS NON DISPONIBLES (N'EXISTENT PAS):
❌ FUNCTION CEILING(x)  : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION CEIL(x)     : N'existe pas! Utilise INTEGER(x + 0.999) à la place
❌ FUNCTION FLOOR(x)    : N'existe pas! Utilise INTEGER(x) à la place
❌ FUNCTION ROUND(x, n) : N'existe pas! Utilise COMPUTE ... ROUNDED à la place
❌ FUNCTION SQRT(x)     : N'existe pas!
❌ FUNCTION POW(x, y)   : N'existe pas!
❌ FUNCTION EXP(x)      : N'existe pas!
❌ FUNCTION LOG(x)      : N'existe pas!
❌ IF var NUMERIC = FALSE : N'existe pas! Utilise IF var IS NOT NUMERIC à la place

ARRONDI SUPÉRIEUR (équivalent CEILING):
Pour arrondir au supérieur, utilise cette technique:
  COMPUTE result = FUNCTION INTEGER(value + 0.999)

EXEMPLE CEILING:
  value = 5.2  → FUNCTION INTEGER(5.2 + 0.999) = INTEGER(6.199) = 6  ✓
  value = 5.0  → FUNCTION INTEGER(5.0 + 0.999) = INTEGER(5.999) = 5  ✓
  value = -3.5 → FUNCTION INTEGER(-3.5 + 0.999) = INTEGER(-2.501) = -2  ✓

ARRONDI STANDARD:
Préfère toujours COMPUTE ... ROUNDED au lieu de FUNCTION:
  ✅ CORRECT:   COMPUTE result ROUNDED = value1 * value2
  ❌ INTERDIT:  COMPUTE result = FUNCTION ROUND(value1 * value2)

VALIDATION NUMERIC:
Utilise IS NUMERIC ou IS NOT NUMERIC pour tester si un champ alphanumérique contient des chiffres:
  ✅ CORRECT:   IF var IS NUMERIC THEN ...
  ✅ CORRECT:   IF var IS NOT NUMERIC THEN ...
  ❌ INTERDIT:  IF var NUMERIC = FALSE ...

IMPORTANT: Si tu dois arrondir, utilise COMPUTE ROUNDED, PAS FUNCTION ROUND.

ERREUR DE COMPILATION SI TU UTILISES UNE FONCTION INEXISTANTE:
Si tu génères FUNCTION CEILING, CEIL, FLOOR, ROUND, SQRT, POW, etc.,
le compilateur GnuCOBOL retournera: "erreur : FUNCTION « XXX » inconnue"
et la compilation ÉCHOUERA.


=== SQL EMBARQUÉ OCESQL (CRITIQUE - PRIORITÉ ABSOLUE) ===
Contexte: workflow OCESQL en mode précompilation (ex: `ocesql file.cbl file.cob`).
Le fichier source `.cbl` DOIT contenir du SQL EMBARQUÉ standard (`EXEC SQL ... END-EXEC`).
Le précompilateur traduit automatiquement les blocs `EXEC SQL` en appels runtime (ex: `CALL 'OCESQLExec' USING SQLCA ...`).
Donc: NE PAS écrire d'appels OCESQL* dans le `.cbl`.

1) RÈGLES ABSOLUES (à respecter même si des specs mentionnent OCESQL*)
INTERDIT dans le `.cbl` source:
❌ CALL 'OCESQLStartSQL' ...
❌ CALL 'OCESQLConnect' ...
❌ CALL 'OCESQLEndSQL' ...
❌ CALL 'OCESQLExec' ...
❌ CALL 'OCESQLDisconnect' ...
❌ EXEC SQL CALL OCESQL... END-EXEC

Toujours utiliser uniquement:
✅ EXEC SQL <statement SQL standard> END-EXEC

2) RÈGLES DE FORME (évite les sorties qui compilent mais ne marchent pas)
- Chaque bloc SQL DOIT être complet et fermé:
  ✅ commence par `EXEC SQL`
  ✅ se termine par `END-EXEC` sur la même instruction
  ❌ INTERDIT: une ligne `EXEC SQL` seule (sans statement)
  ❌ INTERDIT: un `DECLARE ...` séparé sans `EXEC SQL ... END-EXEC` complet

- Ne jamais dupliquer SQLCA:
  ✅ `EXEC SQL INCLUDE SQLCA END-EXEC.` doit exister UNE seule fois en WORKING-STORAGE
  ❌ ne jamais générer `INCLUDE SQLCA` dans PROCEDURE / steps

3) CONNEXION / COMMIT / DÉCONNEXION (formes attendues)
CONNEXION:
✅ EXEC SQL CONNECT :USER IDENTIFIED BY :PASSWORD USING :DBNAME END-EXEC.

COMMIT:
✅ EXEC SQL COMMIT END-EXEC.

DÉCONNEXION:
✅ EXEC SQL DISCONNECT ALL END-EXEC.

IMPORTANT (HOST VARIABLES pour CONNECT):
Les host variables SQL `:var` doivent être des champs ÉLÉMENTAIRES COBOL.
Si un identifiant est un GROUPE (ex: `WS-DB-USER`) et qu'il existe un champ `WS-DB-USER-TEXT`,
ALORS utiliser `:WS-DB-USER-TEXT` (et idem pour PASSWORD/DBNAME).

✅ CORRECT (utilise les champs élémentaires *-TEXT):
    EXEC SQL CONNECT :WS-DB-USER-TEXT IDENTIFIED BY :WS-DB-PASSWORD-TEXT
        USING :WS-DB-NAME-TEXT
    END-EXEC

❌ FAUX (utilise un GROUPE comme host variable):
    EXEC SQL CONNECT :WS-DB-USER IDENTIFIED BY :WS-DB-PASSWORD USING :WS-DB-NAME END-EXEC

4) CURSEURS (ordre obligatoire + séquence complète)
RÈGLE: l'ordre est STRICT et la séquence doit être cohérente dans le même paragraphe/flux.
Tu ne peux pas OPEN/FETCH un curseur non déclaré.

✅ ÉTAPE 1 — DECLARE (AVANT toute utilisation, généralement en début de paragraphe ou section dédiée):
    EXEC SQL DECLARE cursor-name CURSOR FOR
        SELECT col1, col2 FROM table
    END-EXEC

✅ ÉTAPE 2 — OPEN (APRÈS DECLARE):
    EXEC SQL OPEN cursor-name END-EXEC

✅ ÉTAPE 3 — FETCH (APRÈS OPEN):
    EXEC SQL FETCH cursor-name INTO :var1, :var2 END-EXEC

✅ ÉTAPE 4 — CLOSE (APRÈS FETCH et avant sortie du flux):
    EXEC SQL CLOSE cursor-name END-EXEC

INTERDIT / erreurs fréquentes:
❌ OPEN sans DECLARE
❌ DECLARE placé après OPEN (ou en fin de fichier)
❌ `EXEC SQL` isolé sans statement
❌ FETCH avant OPEN
❌ CLOSE avant OPEN/FETCH

5) RÈGLE ABSOLUE ANTI-TRAILING SPACES (données enum/status)
Les champs COBOL `PIC X(n)` sont space-padded. Si tu écris directement `:WS-STATUS` en base,
la base stocke souvent `OK       ` / `LOW       ` / `BLOCKED   ` au lieu de `OK` / `LOW` / `BLOCKED`.
Ça casse ensuite les comparaisons exactes (`WHERE status = 'OK'`) et les tests stricts.

Donc, pour les colonnes de type "enum/status/short string" (ex: risk_level, compliance_status, etc.),
tu DOIS normaliser côté SQL lors de l'UPDATE/INSERT (sans changer la valeur logique):

✅ CORRECT (normalisation côté SQL):
    EXEC SQL UPDATE OPERATION
        SET RISK_LEVEL = RTRIM(:WS-RISK-LEVEL),
            COMPLIANCE_STATUS = RTRIM(:WS-COMPLIANCE-STATUS)
        WHERE OP_ID = :WS-OP-ID
    END-EXEC

✅ Alternative acceptable (si RTRIM non souhaité):
    utiliser TRIM(:var) (TRIM = enlever espaces des deux côtés)

❌ FAUX (stocke la valeur paddée):
    EXEC SQL UPDATE OPERATION
        SET RISK_LEVEL = :WS-RISK-LEVEL
        WHERE OP_ID = :WS-OP-ID
    END-EXEC

6) CHECK ERREUR SQL (pattern attendu)
Après un CONNECT/UPDATE/INSERT/SELECT important, vérifier SQLCODE:

    IF SQLCODE NOT EQUAL ZERO
        DISPLAY 'ERREUR SQL: SQLCODE=' SQLCODE
        GOBACK
    END-IF

RAPPEL:
- Tu n'écris PAS les appels OCESQL* dans le `.cbl`.
- Tu écris du `EXEC SQL ... END-EXEC` standard.
- Host variables: champs élémentaires (préférer `*-TEXT` si un groupe existe).
- Curseurs: DECLARE → OPEN → FETCH → CLOSE, dans cet ordre strict.
- Enum/status: RTRIM/TRIM à l'écriture SQL pour éviter les espaces stockés.


=== STRATEGY ===
1) Construis d'abord le squelette COBOL complet (DIVISION/SECTION) dans l'ordre.
2) Insere les blocs WORKING-STORAGE/LINKAGE exacts fournis par la spec.
3) Ecris la PROCEDURE DIVISION en suivant le flow et les fonctions.
4) REGLE CRITIQUE FERMETURE: Pour toute fonction ouverte (OPEN cursor, EVALUATE, IF, PERFORM), tu DOIS la fermer (CLOSE, END-EVALUATE, END-IF, END-PERFORM).
5) Verifie la coherence: aucune variable/paragraphes inventes.

=== CONTEXT ===
Programme: HEBERGEMENT-DAL-DB (couche dal)
SGBD: postgres. Dialecte COBOL: gnucobol.
Table HEBERGEMENT: HEBERGEMENT_ID INT PK, HEBERGEMENT_ID_ACTIVITE INT, HEBERGEMENT_TYPE INT, HEBERGEMENT_NBNUIT INT

=== REQUIREMENTS ===
Exigences (spec):
[R4][technique] Toutes les operations BD sont realisees en COBOL embarque SQL PostgreSQL (OCESQL).

=== STYLE ===
Guidelines globales: Format FIXED: instructions commencent en colonne 8 (prefixe de 7 espaces).
Commentaires: '*' en colonne 7 (6 espaces + '*'), pas de commentaires '*>'.
Ne pas utiliser '>>SOURCE FORMAT FREE'.
PARAGRAPHES: Nom + point sur meme ligne. Format: MAIN-PROCESS. JAMAIS de point seul sur ligne.
En DATA DIVISION, chaque ligne 01/05/77/88 avec PIC ou VALUE se termine par un point.
Aucune ligne ne doit depasser 72 colonnes (format FIXED).
Si une instruction depasse 72 colonnes, la scinder sur plusieurs lignes.
Pour EXEC SQL FETCH/SELECT/UPDATE: mettre chaque variable hote sur sa propre ligne.
Ne pas mettre de point en fin de DISPLAY/GOBACK/STOP RUN/CALL/MOVE/IF (sauf EXEC SQL INCLUDE SQLCA END-EXEC.).
Utiliser des guillemets simples pour les messages DISPLAY.
Respecter l'ordre: IDENTIFICATION -> ENVIRONMENT -> DATA -> PROCEDURE.
Dans DATA: WORKING-STORAGE puis LINKAGE (si present).
Header commentaire (verbatim):
      *****************************************************************
      * Programme: HEBERGEMENT-DAL-DB                                 *
      * Couche: DAL (Data Access Layer)                               *
      * Role: Acces a la base PostgreSQL pour HEBERGEMENT                    *
      *       Operations: READ, SAVE, END                             *
      *****************************************************************
Style specifique: CALL OCESQL avec guillemets doubles et END-CALL.
OCESQLConnect avec BY REFERENCE/ BY VALUE (ordre exact).
EXIT PARAGRAPH sur erreur OPEN du curseur.
EVALUATE SQLCODE apres FETCH.
Apres DAL-CONNECT, si NOT WS-CONNECTED: MOVE 'Y' TO LK-END-OF-FILE puis GOBACK.
MAIN-ENTRY se termine strictement par END-EVALUATE, puis GOBACK, puis '.'.

=== FORMAT ===
Format COBOL: line_format: fixed
indent_spaces: 7
max_line_length: 72
comment: column=7, prefix=*
literal_quotes: single
paragraph_terminator: .
allow_source_format_directive: False

=== NAMING ===
Conventions de nommage: variables_case=UPPER_SNAKE, programmes_case=UPPER-KEBAB
prefixes: flags=WS-, linkage=LK-, working_storage=WS-
paragraph_style: VERB-NOUN

=== ENVIRONMENT ===
ENVIRONMENT DIVISION.
CONFIGURATION SECTION.
REPOSITORY.
    FUNCTION ALL INTRINSIC.

=== INTERFACE ===
Interface CALL/USING: LK-OPERATION: X(4) (direction: in); LK-END-OF-FILE: X (direction: inout); LK-HEBERGEMENT: groupe HEBERGEMENT (direction: inout)

=== STRUCTURE ===
LINKAGE SECTION.
01 LK-OPERATION PIC X(4).
01 LK-END-OF-FILE PIC X.
01 LK-HEBERGEMENT.
    05 LK-HEBERGEMENT-ID PIC 9(9).
    05 LK-HEBERGEMENT-ID-ACTIVITE PIC 9(9).
    05 LK-HEBERGEMENT-TYPE PIC 9(2).
    05 LK-HEBERGEMENT-NBNUIT PIC S9(3).

PROCEDURE DIVISION USING LK-OPERATION LK-END-OF-FILE LK-HEBERGEMENT.

=== WORKING_STORAGE ===
EXEC SQL INCLUDE SQLCA END-EXEC.
01  WS-CONNECTED-FLAG      PIC X VALUE 'N'.
88  WS-CONNECTED           VALUE 'Y'.
01  WS-CURSOR-OPEN-FLAG    PIC X VALUE 'N'.
88  WS-CURSOR-OPEN         VALUE 'Y'.
01  WS-HEBERGEMENT-ID      PIC 9(9).
01  WS-HEBERG-ID-ACTIVITE  PIC 9(9).
01  WS-HEBERGEMENT-TYPE    PIC 9(2).
01  WS-HEBERGEMENT-NBNUIT  PIC S9(3).
01  WS-DB-NAME.
05  WS-DB-NAME-TEXT     PIC X(13) VALUE 'carbontrackdb'.
05  WS-DB-NAME-TERM     PIC X VALUE X'00'.
01  WS-DB-USER.
05  WS-DB-USER-TEXT     PIC X(10) VALUE 'carbonuser'.
05  WS-DB-USER-TERM     PIC X VALUE X'00'.
01  WS-DB-PASSWORD.
05  WS-DB-PASSWORD-TEXT PIC X(9) VALUE 'CARBONPWD'.
05  WS-DB-PASSWORD-TERM PIC X VALUE X'00'.
01  WS-DB-NAME-LEN         PIC S9(4) COMP-5 VALUE 13.
01  WS-DB-USER-LEN         PIC S9(4) COMP-5 VALUE 10.
01  WS-DB-PASSWORD-LEN     PIC S9(4) COMP-5 VALUE 9.
01  WS-PGHOST-NAME         PIC X(6) VALUE 'PGHOST'.
01  WS-PGHOST-VALUE        PIC X(64) VALUE 'localhost'.
01  WS-PGPORT-NAME         PIC X(6) VALUE 'PGPORT'.
01  WS-PGPORT-VALUE        PIC X(5) VALUE '5432'.
01  WS-PGUSER-NAME         PIC X(6) VALUE 'PGUSER'.
01  WS-PGUSER-VALUE        PIC X(64) VALUE 'carbonuser'.
01  WS-PGPASSWORD-NAME     PIC X(10) VALUE 'PGPASSWORD'.
01  WS-PGPASSWORD-VALUE    PIC X(64) VALUE 'CARBONPWD'.
01  WS-PGDATABASE-NAME     PIC X(10) VALUE 'PGDATABASE'.
01  WS-PGDATABASE-VALUE    PIC X(64) VALUE 'carbontrackdb'.

=== SQL ===
engine=postgres, method=ocesql, host=localhost, port=5432, dbname=carbontrackdb, user=carbonuser
env_vars: PGDATABASE=carbontrackdb, PGHOST=localhost, PGPASSWORD=CARBONPWD, PGPORT=5432, PGUSER=carbonuser
env_set_method: DISPLAY <ENV_NAME> UPON ENVIRONMENT-NAME | DISPLAY <ENV_VALUE> UPON ENVIRONMENT-VALUE
OCESQL calls: OCESQLStartSQL, OCESQLConnect, OCESQLEndSQL
connect_args: SQLCA, WS-DB-USER, WS-DB-USER-LEN, WS-DB-PASSWORD, WS-DB-PASSWORD-LEN, WS-DB-NAME, WS-DB-NAME-LEN
CRITIQUE: RESPECTE EXACTEMENT L'ORDRE des parametres ci-dessus dans le CALL. Ne les inverse JAMAIS. order: SQLCA, user, user_len, password, password_len, dbname, dbname_len
DAL-CONNECT:
  connection_calls: CALL "OCESQLStartSQL" END-CALL
  connection_calls: CALL "OCESQLConnect" USING BY REFERENCE SQLCA BY REFERENCE WS-DB-USER BY VALUE WS-DB-USER-LEN BY REFERENCE WS-DB-PASSWORD BY VALUE WS-DB-PASSWORD-LEN BY REFERENCE WS-DB-NAME BY VALUE WS-DB-NAME-LEN END-CALL
  connection_calls: CALL "OCESQLEndSQL" END-CALL
  connection_method: OCESQL (voir sql.connection)
DAL-READ:
  declare_cursor: DECLARE C_HEB CURSOR FOR
SELECT HEBERGEMENT_ID, HEBERGEMENT_ID_ACTIVITE,
       HEBERGEMENT_TYPE, HEBERGEMENT_NBNUIT
FROM HEBERGEMENT
ORDER BY HEBERGEMENT_ID

  fetch_into: FETCH C_HEB INTO :WS-HEBERGEMENT-ID, :WS-HEBERG-ID-ACTIVITE, :WS-HEBERGEMENT-TYPE, :WS-HEBERGEMENT-NBNUIT
  open_cursor: OPEN C_HEB
DAL-SAVE:
  update_statement: UPDATE HEBERGEMENT
SET HEBERGEMENT_NBNUIT = :WS-HEBERGEMENT-NBNUIT
WHERE HEBERGEMENT_ID = :WS-HEBERGEMENT-ID

DAL-END:
  close_cursor: CLOSE C_HEB
  commit: COMMIT
  disconnect: DISCONNECT ALL

=== SQL_FORMAT ===
max_line_length: 72
host_vars_one_per_line: True
split_long_exec_sql: True

=== SQL_BEHAVIOR ===
check_sqlcode: True
check_sqlstate: True
sqlcode_success: 0
sqlcode_eof: 100
rollback_on_error: False
commit: mode=end, statement=EXEC SQL COMMIT END-EXEC.
disconnect: statement=EXEC SQL DISCONNECT ALL END-EXEC.
null_indicators: False

=== POLITIQUE COMMIT/CURSOR (CRITIQUE) ===
cursor_commit_policy: no_commit_while_open

SIGNIFICATION:
- Le curseur DOIT rester ouvert pendant tout le traitement
- PostgreSQL ferme automatiquement les curseurs non-WITH-HOLD sur COMMIT
- DONC: NE PAS mettre EXEC SQL COMMIT dans les fonctions du traitement

RÈGLES STRICTES:
✅ COMMIT AUTORISÉ dans: DAL-CONNECT, DAL-READ, DAL-END
❌ COMMIT INTERDIT dans: DAL-SET-ENV, DAL-SAVE

POURQUOI:
- Un COMMIT dans une fonction du traitement fermerait le curseur
- Les prochains FETCH échoueraient avec SQLCODE=-400 (curseur fermé)
- Le batch s'arrêterait prématurément après 1 seul enregistrement

SI ERREUR UPDATE/INSERT/DELETE:
- ✅ AUTORISÉ: EXEC SQL ROLLBACK END-EXEC (annule sans fermer curseur)
- ❌ INTERDIT: EXEC SQL COMMIT END-EXEC (fermerait le curseur)
- Le COMMIT final sera fait dans DAL-CONNECT


=== FLOW ===
MAIN-ENTRY: IF LK-OPERATION NOT = 'END ' THEN PERFORM DAL-CONNECT; IF NOT WS-CONNECTED THEN MOVE 'Y' TO LK-END-OF-FILE, GOBACK; END-IF; END-IF
EVALUATE LK-OPERATION: READ->DAL-READ, SAVE->DAL-SAVE, END->DAL-END, OTHER->DISPLAY erreur
GOBACK apres EVALUATE
DAL-READ: ouverture curseur paresseuse, FETCH, mise a jour EOF
DAL-SAVE: UPDATE HEBERGEMENT_NBNUIT
DAL-END: CLOSE cursor, COMMIT, DISCONNECT, reset flags

=== LOGGING ===
Connexion DB reussie: carbontrackdb
ERREUR CONNECT: SQLCODE=
SQLSTATE=
SQLERRMC=
Curseur C_HEB ouvert
ERREUR OPEN: SQLCODE=
ERREUR FETCH: SQLCODE=
ERREUR UPDATE: SQLCODE=
ERREUR CLOSE: SQLCODE=
ERREUR COMMIT: SQLCODE=
ERREUR DISCONNECT: SQLCODE=
ERREUR: Operation inconnue: 
Fermeture connexion

=== CONSTRAINTS ===
Interdictions: GO TO, *>
Paragraphes publics attendus: DAL-READ, DAL-SAVE, DAL-END
Paragraphes internes autorises: DAL-CONNECT, DAL-SET-ENV, DAL-CONNECT, DAL-SET-ENV
Entry paragraph: MAIN-ENTRY

=== SKELETON ===
Squelette attendu (rappel structure):
IDENTIFICATION DIVISION.
PROGRAM-ID. HEBERGEMENT-DAL-DB.
      *****************************************************************
      * Programme: HEBERGEMENT-DAL-DB                                 *
      * Couche: DAL (Data Access Layer)                               *
      * Role: Acces a la base PostgreSQL pour HEBERGEMENT                    *
      *       Operations: READ, SAVE, END                             *
      *****************************************************************
ENVIRONMENT DIVISION.
CONFIGURATION SECTION.
REPOSITORY.
    FUNCTION ALL INTRINSIC.
DATA DIVISION.
WORKING-STORAGE SECTION.
EXEC SQL INCLUDE SQLCA END-EXEC.
01  WS-CONNECTED-FLAG      PIC X VALUE 'N'.
88  WS-CONNECTED           VALUE 'Y'.
01  WS-CURSOR-OPEN-FLAG    PIC X VALUE 'N'.
88  WS-CURSOR-OPEN         VALUE 'Y'.
01  WS-HEBERGEMENT-ID      PIC 9(9).
01  WS-HEBERG-ID-ACTIVITE  PIC 9(9).
01  WS-HEBERGEMENT-TYPE    PIC 9(2).
01  WS-HEBERGEMENT-NBNUIT  PIC S9(3).
01  WS-DB-NAME.
05  WS-DB-NAME-TEXT     PIC X(13) VALUE 'carbontrackdb'.
05  WS-DB-NAME-TERM     PIC X VALUE X'00'.
01  WS-DB-USER.
05  WS-DB-USER-TEXT     PIC X(10) VALUE 'carbonuser'.
05  WS-DB-USER-TERM     PIC X VALUE X'00'.
01  WS-DB-PASSWORD.
05  WS-DB-PASSWORD-TEXT PIC X(9) VALUE 'CARBONPWD'.
05  WS-DB-PASSWORD-TERM PIC X VALUE X'00'.
01  WS-DB-NAME-LEN         PIC S9(4) COMP-5 VALUE 13.
01  WS-DB-USER-LEN         PIC S9(4) COMP-5 VALUE 10.
01  WS-DB-PASSWORD-LEN     PIC S9(4) COMP-5 VALUE 9.
01  WS-PGHOST-NAME         PIC X(6) VALUE 'PGHOST'.
01  WS-PGHOST-VALUE        PIC X(64) VALUE 'localhost'.
01  WS-PGPORT-NAME         PIC X(6) VALUE 'PGPORT'.
01  WS-PGPORT-VALUE        PIC X(5) VALUE '5432'.
01  WS-PGUSER-NAME         PIC X(6) VALUE 'PGUSER'.
01  WS-PGUSER-VALUE        PIC X(64) VALUE 'carbonuser'.
01  WS-PGPASSWORD-NAME     PIC X(10) VALUE 'PGPASSWORD'.
01  WS-PGPASSWORD-VALUE    PIC X(64) VALUE 'CARBONPWD'.
01  WS-PGDATABASE-NAME     PIC X(10) VALUE 'PGDATABASE'.
01  WS-PGDATABASE-VALUE    PIC X(64) VALUE 'carbontrackdb'.
PROCEDURE DIVISION USING LK-OPERATION LK-END-OF-FILE LK-HEBERGEMENT.

=== FONCTIONS ===
- DAL-CONNECT: Connexion paresseuse a la base via OCESQL. Initialise les variables d environnement PostgreSQL, puis execute OCESQLStartSQL/OCESQLConnect/OCESQLEndSQL.
  visibility: internal, required: True
  Outputs: SQLCODE, SQLSTATE
- DAL-SET-ENV: Force les variables d environnement PGHOST/PGPORT/PGUSER/PGPASSWORD/PGDATABASE.
  visibility: internal, required: True
  Steps:
    - DISPLAY WS-PGHOST-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGHOST-VALUE UPON ENVIRONMENT-VALUE
    - DISPLAY WS-PGPORT-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGPORT-VALUE UPON ENVIRONMENT-VALUE
    - DISPLAY WS-PGUSER-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGUSER-VALUE UPON ENVIRONMENT-VALUE
    - DISPLAY WS-PGPASSWORD-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGPASSWORD-VALUE UPON ENVIRONMENT-VALUE
    - DISPLAY WS-PGDATABASE-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGDATABASE-VALUE UPON ENVIRONMENT-VALUE
- DAL-READ: Ouvre le curseur C_HEB si necessaire, fait un FETCH et remplit la structure HEBERGEMENT. Met END-OF-FILE a 'Y' en cas de fin de donnees ou d erreur.
  visibility: public, required: True
  Inputs: OPERATION = 'READ', Connexion deja etablie par MAIN-ENTRY (sauf OPERATION='END ')., Curseur non garanti ouvert (ouverture paresseuse).
  Outputs: HEBERGEMENT.HEBERGEMENT_ID, HEBERGEMENT.HEBERGEMENT_ID_ACTIVITE, HEBERGEMENT.HEBERGEMENT_TYPE, HEBERGEMENT.HEBERGEMENT_NBNUIT, END-OF-FILE, SQLCODE
  Steps:
    - PERFORM DAL-CONNECT
    - IF NOT WS-CONNECTED
    - MOVE 'Y' TO LK-END-OF-FILE
    - GOBACK
    - END-IF
    - IF NOT WS-CURSOR-OPEN
    - EXEC SQL DECLARE C_HEB CURSOR FOR
    - SELECT HEBERGEMENT_ID, HEBERGEMENT_ID_ACTIVITE,
    - HEBERGEMENT_TYPE, HEBERGEMENT_NBNUIT
    - FROM HEBERGEMENT
    - ORDER BY HEBERGEMENT_ID
    - END-EXEC
    - EXEC SQL OPEN C_HEB END-EXEC
    - IF SQLCODE NOT EQUAL ZERO
    - DISPLAY 'ERREUR OPEN: SQLCODE=' SQLCODE
    - MOVE 'Y' TO LK-END-OF-FILE
    - EXEC SQL ROLLBACK END-EXEC
    - GOBACK
    - END-IF
    - SET WS-CURSOR-OPEN TO TRUE
    - DISPLAY 'Curseur C_HEB ouvert'
    - END-IF
    - EXEC SQL FETCH C_HEB INTO
    - :WS-HEBERGEMENT-ID,
    - :WS-HEBERG-ID-ACTIVITE,
    - :WS-HEBERGEMENT-TYPE,
    - :WS-HEBERGEMENT-NBNUIT
    - END-EXEC
    - EVALUATE SQLCODE
    - WHEN 0
    - MOVE WS-HEBERGEMENT-ID TO HEBERGEMENT-ID OF LK-HEBERGEMENT
    - MOVE WS-HEBERG-ID-ACTIVITE TO HEBERGEMENT-ID-ACTIVITE OF LK-HEBERGEMENT
    - MOVE WS-HEBERGEMENT-TYPE TO HEBERGEMENT-TYPE OF LK-HEBERGEMENT
    - MOVE WS-HEBERGEMENT-NBNUIT TO HEBERGEMENT-NBNUIT OF LK-HEBERGEMENT
    - WHEN 100
    - MOVE 'Y' TO LK-END-OF-FILE
    - EXEC SQL CLOSE C_HEB END-EXEC
    - MOVE 'N' TO WS-CURSOR-OPEN-FLAG
    - WHEN OTHER
    - DISPLAY 'ERREUR FETCH: SQLCODE=' SQLCODE
    - MOVE 'Y' TO LK-END-OF-FILE
    - EXEC SQL ROLLBACK END-EXEC
    - END-EVALUATE
- DAL-SAVE: Met a jour en base la colonne HEBERGEMENT_NBNUIT pour l hebergement courant (HEBERGEMENT_ID).
  visibility: public, required: True
  Inputs: HEBERGEMENT.HEBERGEMENT_ID, HEBERGEMENT.HEBERGEMENT_NBNUIT
  Outputs: SQLCODE
  Steps:
    - MOVE HEBERGEMENT-ID OF LK-HEBERGEMENT TO WS-HEBERGEMENT-ID
    - MOVE HEBERGEMENT-NBNUIT OF LK-HEBERGEMENT TO WS-HEBERGEMENT-NBNUIT
    - EXEC SQL UPDATE HEBERGEMENT
    - SET HEBERGEMENT_NBNUIT = :WS-HEBERGEMENT-NBNUIT
    - WHERE HEBERGEMENT_ID = :WS-HEBERGEMENT-ID
    - END-EXEC
    - IF SQLCODE NOT = 0
    - DISPLAY 'ERREUR UPDATE: SQLCODE=' SQLCODE
    - EXEC SQL ROLLBACK END-EXEC
    - MOVE 'Y' TO LK-END-OF-FILE
    - END-IF
- DAL-END: Ferme le curseur s il est ouvert, commit la transaction et ferme la connexion a la base.
  visibility: public, required: True
  Outputs: SQLCODE
  Steps:
    - IF WS-CURSOR-OPEN
    - EXEC SQL CLOSE C_HEB END-EXEC
    - MOVE 'N' TO WS-CURSOR-OPEN-FLAG
    - IF SQLCODE NOT = 0
    - DISPLAY 'ERREUR CLOSE: SQLCODE=' SQLCODE
    - END-IF
    - END-IF
    - EXEC SQL COMMIT END-EXEC
    - IF SQLCODE NOT = 0
    - DISPLAY 'ERREUR COMMIT: SQLCODE=' SQLCODE
    - END-IF
    - IF WS-CONNECTED
    - EXEC SQL DISCONNECT ALL END-EXEC
    - MOVE 'N' TO WS-CONNECTED-FLAG
    - IF SQLCODE NOT = 0
    - DISPLAY 'ERREUR DISCONNECT: SQLCODE=' SQLCODE
    - END-IF
    - DISPLAY 'Fermeture connexion'
    - END-IF

Tache : genere le programme COBOL complet respectant ces contraintes (code seulement).

Les erreurs suivantes ont été détectées, corrige-les strictement sans ajouter de texte explicatif:
- Point final interdit sur instruction (utiliser '.' uniquement sur ligne seule).
- END-IF manquant pour la condition de bloc MAIN-ENTRY.
- Sequence MAIN-ENTRY incomplete: GOBACK manquant.