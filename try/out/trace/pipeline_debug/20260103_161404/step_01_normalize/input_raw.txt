# Exemple 1 — Salaire net (NET = BRUT * 0.7 arrondi à 2 décimales)
title: CALCUL-SALAIRE
dialecte_cobol: gnucobol
sql_cible: postgres

nommage:
  variables_case: UPPER_SNAKE      # ex : SALARY_NET, END-OF-FILE
  programmes_case: UPPER-KEBAB     # ex : EMPLOYEE-DAL-DB, EMPLOYEE-LOGIC

fonctionnalites:
  - id: F1
    resume: "Calculer le salaire net à partir du salaire brut pour chaque employé."

exigences:
  - id: R1
    type: regle_metier
    regle: "SALARY_NET = ROUND(SALARY_BRUT * 0.7, 2)"
    notes: "Salaire net = salaire brut − cotisations sociales (20%) − impôt (10%). Arrondi bancaire à 2 décimales. SALARY_NET ne doit pas être négatif."
  - id: R2
    type: technique
    regle: "Traitement batch quotidien; journalisation des exécutions (messages simples sur la console)."
  - id: R3
    type: validation
    regle: "Si SALARY_BRUT est NULL ou invalide, ignorer la ligne ou la signaler en anomalie."

mcd:
  entites:
    - name: EMPLOYEE
      attrs:
        - name: EMP_ID
          type: INT
          sql_type: INT
          cobol_pic: "9(4)"
          pk: true
          nullable: false
        - name: EMP_NAME
          type: VARCHAR(30)
          sql_type: VARCHAR(30)
          cobol_pic: "A(30)"
          nullable: false
        - name: SALARY_BRUT
          type: DECIMAL(8,2)
          sql_type: DECIMAL(8,2)
          cobol_pic: "9(6)V99"
          nullable: false
        - name: SALARY_NET
          type: DECIMAL(8,2)
          sql_type: DECIMAL(8,2)
          cobol_pic: "9(6)V99"
          nullable: true
  relations: []

diagramme: |
  erDiagram
    EMPLOYEE {
      INT EMP_ID PK
      VARCHAR EMP_NAME
      DECIMAL SALARY_BRUT
      DECIMAL SALARY_NET
    }

sql:
  ddl:
    EMPLOYEE: |
      CREATE TABLE EMPLOYEE (
          EMP_ID INT PRIMARY KEY,
          EMP_NAME VARCHAR(30),
          SALARY_BRUT DECIMAL(8,2),
          SALARY_NET DECIMAL(8,2)
      );
  initial_data:
    EMPLOYEE:
      - EMP_ID: 1
        EMP_NAME: "Dupont"
        SALARY_BRUT: 3000.00
        SALARY_NET: 0.00
      - EMP_ID: 2
        EMP_NAME: "Durand"
        SALARY_BRUT: 1500.00
        SALARY_NET: 0.00
  indexes:
    - entity: EMPLOYEE
      name: EMPLOYEE_EMP_NAME_IDX
      columns: [EMP_NAME]

# Règles générales de mapping (pour d'autres cas réutilisables)
mapping_types:
  - sql: "INT"
    cobol_pic_default: "9(4)"
  - sql: "VARCHAR(30)"
    cobol_pic_default: "A(30)"
  - sql: "DECIMAL(8,2)"
    cobol_pic_default: "9(6)V99"

technique:
  cursor_naming:
    pattern: "C_<ENTITY_UPPER3>"
    example:
      EMPLOYEE: "C_EMP"
  eof_flag:
    name: "END-OF-FILE"
    pic: "X"
    initial_value: "N"
    true_value: "Y"
    false_value: "N"
  sqlca_required: true   # la DAL doit inclure SQLCA dès qu'elle utilise SQLCODE
  dal_call_pattern:
    description: "Programme DAL appelé avec un code opération court (READ, SAVE, END)."
    operation_param_name: "OPERATION"
    operation_pic: "X(4)"
    eof_param_name: "END-OF-FILE"
    employee_param_name: "EMPLOYEE"

sources:
  cobol:
    - programme: EMPLOYEE-DAL-DB
      fichier: "employee_dal_db.cob"
    - programme: EMPLOYEE-LOGIC
      fichier: "employee_logic.cob"
    - programme: EMPLOYEE-BUSINESS
      fichier: "employee_business.cob"
  sql:
    - logical_name: "EMPLOYEE-INIT"
      fichier: "employee_init.sql"
      entity: EMPLOYEE

programmes:
  - name: EMPLOYEE-DAL-DB
    layer: dal
    role: "Couche d'accès à la base pour EMPLOYEE (lecture via curseur et mise à jour de SALARY_NET)."
    entities: [EMPLOYEE]
    allowed_sql: true
    allowed_business_logic: false
    main_cursor: "C_EMP"
    call_interface:
      type: "CALL USING"
      description: "CALL 'EMPLOYEE-DAL-DB' USING OPERATION, END-OF-FILE, EMPLOYEE."
      linkage_parameters:
        - name: "LK-OPERATION"
          pic: "X(4)"
          direction: in
        - name: "LK-END-OF-FILE"
          pic: "X"
          direction: inout
        - name: "LK-EMPLOYEE"
          pic: "groupe EMPLOYEE"
          direction: inout
      operations:
        read: "READ"
        save: "SAVE"
        end: "END "
    cobol_sections:
      identification_division: required
      environment_division: optional
      data_division:
        working_storage: required
        linkage: required
      procedure_division:
        using_clause: ["LK-OPERATION", "LK-END-OF-FILE", "LK-EMPLOYEE"]
        entry_paragraph: "MAIN-ENTRY"

  - name: EMPLOYEE-LOGIC
    layer: logic
    role: "Traitement batch principal : boucle sur les employés, calcul du net, sauvegarde, affichage."
    entities: [EMPLOYEE]
    allowed_sql: false
    allowed_business_logic: true
    cobol_sections:
      identification_division: required
      environment_division: optional
      data_division:
        working_storage: required
        linkage: none
      procedure_division:
        entry_paragraph: "MAIN-PROCESS"

  - name: EMPLOYEE-BUSINESS
    layer: business
    role: "Affichage simple des informations d'un employé (nom, ID, salaire brut/net)."
    entities: [EMPLOYEE]
    allowed_sql: false
    allowed_business_logic: "lecture_seule"
    cobol_sections:
      identification_division: required
      environment_division: optional
      data_division:
        working_storage: none
        linkage: required
      procedure_division:
        using_clause: ["EMPLOYEE"]
        entry_paragraph: "DISPLAY-EMPLOYEE"

fonctions:
  # --- Couche DAL / Physique ---

  - id: FN-DAL-READ
    name: DAL-READ
    programme: EMPLOYEE-DAL-DB
    layer: dal
    entity: EMPLOYEE
    description: >
      Connecte à la base si nécessaire, ouvre le curseur C_EMP si nécessaire,
      fait un FETCH et remplit la structure EMPLOYEE. Met END-OF-FILE à 'Y'
      en cas de fin de données ou d'erreur.
    operation_code: "READ"
    inputs:
      - "OPERATION = 'READ'"
      - "Connexion non garantie à l'avance (connexion paresseuse)."
      - "Curseur non garanti ouvert (ouverture paresseuse)."
    outputs:
      - "EMPLOYEE.EMP_ID"
      - "EMPLOYEE.EMP_NAME"
      - "EMPLOYEE.SALARY_BRUT"
      - "EMPLOYEE.SALARY_NET"
      - "END-OF-FILE"
      - "SQLCODE"
    modifies:
      - "EMPLOYEE.*"
      - "END-OF-FILE"
      - "WS-CONNECTED"
      - "WS-CURSOR-OPEN"
      - "SQLCODE"
    preconditions: []
    postconditions:
      - "Si SQLCODE = 0 : EMPLOYEE contient un enregistrement valide et END-OF-FILE = 'N'."
      - "Si SQLCODE = 100 : fin de données, END-OF-FILE = 'Y'."
      - "Si SQLCODE != 0 et != 100 : message d'erreur affiché et END-OF-FILE = 'Y'."
    errors_flags:
      - "SQLCODE = 0 : succès, une ligne lue."
      - "SQLCODE = 100 : fin de curseur."
      - "SQLCODE != 0 et != 100 : erreur SQL, le batch s'arrête logiquement."
    related_exigences: [R2, R3]
    sql:
      connect_statement: "CONNECT TO 'dbname=EMPDB user=EMPUSER password=SECRETPWD'"
      declare_cursor: |
        DECLARE C_EMP CURSOR FOR
        SELECT EMP_ID, EMP_NAME, SALARY_BRUT, SALARY_NET
        FROM EMPLOYEE
      open_cursor: "OPEN C_EMP"
      fetch_into: "FETCH C_EMP INTO :LK-EMP-ID, :LK-EMP-NAME, :LK-SALARY-BRUT, :LK-SALARY-NET"
    eof_logic:
      on_sqlcode_100_set_eof: true
      eof_flag_name: "LK-END-OF-FILE"
      eof_true_value: "Y"
      eof_false_value: "N"
    cobol_location:
      fichier: "employee_dal_db.cob"
      programme: "EMPLOYEE-DAL-DB"
      division: "PROCEDURE DIVISION"
      paragraph: "DAL-READ"
      section: "couche_dal"

  - id: FN-DAL-SAVE
    name: DAL-SAVE
    programme: EMPLOYEE-DAL-DB
    layer: dal
    entity: EMPLOYEE
    description: >
      Met à jour en base la colonne SALARY_NET pour l'employé courant (EMP_ID)
      à partir de la valeur SALARY_NET de la structure EMPLOYEE.
    operation_code: "SAVE"
    inputs:
      - "EMPLOYEE.EMP_ID"
      - "EMPLOYEE.SALARY_NET"
    outputs:
      - "SQLCODE"
    modifies:
      - "SQLCODE"
    preconditions:
      - "EMPLOYEE.EMP_ID contient un identifiant existant en base."
    postconditions:
      - "Si SQLCODE = 0 : la ligne EMPLOYEE correspondante en base a été mise à jour."
    errors_flags:
      - "SQLCODE = 0 : succès."
      - "SQLCODE != 0 : erreur SQL, message affiché."
    related_exigences: [R1, R2]
    sql:
      update_statement: |
        UPDATE EMPLOYEE
        SET SALARY_NET = :LK-SALARY-NET
        WHERE EMP_ID = :LK-EMP-ID
    cobol_location:
      fichier: "employee_dal_db.cob"
      programme: "EMPLOYEE-DAL-DB"
      division: "PROCEDURE DIVISION"
      paragraph: "DAL-SAVE"
      section: "couche_dal"

  - id: FN-DAL-END
    name: DAL-END
    programme: EMPLOYEE-DAL-DB
    layer: dal
    entity: EMPLOYEE
    description: >
      Ferme le curseur s'il est ouvert, commit la transaction et ferme la connexion à la base.
      Appelée une fois en fin de traitement.
    operation_code: "END "
    inputs: []
    outputs:
      - "SQLCODE"
    modifies:
      - "WS-CURSOR-OPEN"
      - "WS-CONNECTED"
      - "SQLCODE"
    preconditions: []
    postconditions:
      - "Curseur fermé si besoin."
      - "COMMIT effectué."
      - "Connexion base fermée."
    errors_flags:
      - "Les erreurs de CLOSE/COMMIT/DISCONNECT sont simplement affichées."
    related_exigences: [R2]
    sql:
      close_cursor: "CLOSE C_EMP"
      commit: "COMMIT"
      disconnect: "DISCONNECT ALL"
    cobol_location:
      fichier: "employee_dal_db.cob"
      programme: "EMPLOYEE-DAL-DB"
      division: "PROCEDURE DIVISION"
      paragraph: "DAL-END"
      section: "couche_dal"

  # --- Couche LOGIQUE / Orchestration batch ---

  - id: FN-LOGIC-MAIN
    name: MAIN-PROCESS
    programme: EMPLOYEE-LOGIC
    layer: logic
    entity: EMPLOYEE
    description: >
      Boucle principale du batch: lit les employés via la DAL, calcule le salaire net,
      sauvegarde le résultat en base et affiche chaque employé.
    inputs: []
    outputs: []
    modifies:
      - "EMPLOYEE.*"
      - "END-OF-FILE"
    preconditions: []
    postconditions:
      - "Tous les employés de la table EMPLOYEE ont un SALARY_NET calculé selon R1."
    calls:
      - "EMPLOYEE-DAL-DB avec OPERATION='READ'"
      - "CALCULATE-NET"
      - "EMPLOYEE-DAL-DB avec OPERATION='SAVE'"
      - "EMPLOYEE-BUSINESS.DISPLAY-EMPLOYEE"
      - "EMPLOYEE-DAL-DB avec OPERATION='END '"
    loop_control:
      eof_flag_name: "END-OF-FILE"
      eof_true_value: "Y"
      eof_false_value: "N"
    related_exigences: [F1, R1, R2, R3]
    cobol_location:
      fichier: "employee_logic.cob"
      programme: "EMPLOYEE-LOGIC"
      division: "PROCEDURE DIVISION"
      paragraph: "MAIN-PROCESS"
      section: "couche_logique"

  - id: FN-LOGIC-CALC
    name: CALCULATE-NET
    programme: EMPLOYEE-LOGIC
    layer: logic
    entity: EMPLOYEE
    description: >
      Applique la règle métier SALARY_NET = ROUND(SALARY_BRUT * 0.7, 2) à l'employé courant.
      Aucun accès base, uniquement traitement en mémoire.
    inputs:
      - "EMPLOYEE.SALARY_BRUT"
    outputs:
      - "EMPLOYEE.SALARY_NET"
    modifies:
      - "EMPLOYEE.SALARY_NET"
    preconditions:
      - "EMPLOYEE.SALARY_BRUT contient une valeur numérique valide."
    postconditions:
      - "EMPLOYEE.SALARY_NET >= 0."
      - "EMPLOYEE.SALARY_NET correspond à SALARY_BRUT * 0.7 arrondi à 2 décimales."
    errors_flags:
      - "Si SALARY_BRUT invalide, la logique appelante peut ignorer la ligne ou la journaliser (R3)."
    related_exigences: [R1, R3]
    expression:
      target: "EMPLOYEE.SALARY_NET"
      formula: "ROUND(EMPLOYEE.SALARY_BRUT * 0.7, 2)"
      cobol_hint: "COMPUTE SALARY-NET ROUNDED = SALARY-BRUT * 0.7"
    cobol_location:
      fichier: "employee_logic.cob"
      programme: "EMPLOYEE-LOGIC"
      division: "PROCEDURE DIVISION"
      paragraph: "CALCULATE-NET"
      section: "couche_logique"

  # --- Couche MÉTIER / Présentation ---

  - id: FN-BIZ-DISPLAY
    name: DISPLAY-EMPLOYEE
    programme: EMPLOYEE-BUSINESS
    layer: business
    entity: EMPLOYEE
    description: >
      Affiche les informations principales de l'employé courant sur la console:
      nom, identifiant, salaire brut, salaire net.
    inputs:
      - "EMPLOYEE.EMP_NAME"
      - "EMPLOYEE.EMP_ID"
      - "EMPLOYEE.SALARY_BRUT"
      - "EMPLOYEE.SALARY_NET"
    outputs: []
    modifies: []
    preconditions:
      - "EMPLOYEE contient des valeurs lues/calculées cohérentes."
    postconditions: []
    errors_flags: []
    related_exigences: [F1]
    display_lines:
      - 'DISPLAY "EMPLOYE : " EMP-NAME'
      - 'DISPLAY "ID      : " EMP-ID'
      - 'DISPLAY "BRUT    : " SALARY-BRUT'
      - 'DISPLAY "NET     : " SALARY-NET'
    cobol_location:
      fichier: "employee_business.cob"
      programme: "EMPLOYEE-BUSINESS"
      division: "PROCEDURE DIVISION"
      paragraph: "DISPLAY-EMPLOYEE"
      section: "couche_metier"
# # Exemple 1 — Salaire net (NET = BRUT * 0.7 arrondi à 2 décimales)
# title: CALCUL-SALAIRE
# dialecte_cobol: gnucobol
# sql_cible: postgres
# 
# nommage:
#   variables_case: UPPER_SNAKE      # ex : SALARY_NET, END_OF_FILE
#   programmes_case: UPPER-KEBAB     # ex : EMPLOYEE-DAL-DB, EMPLOYEE-LOGIC
# 
# fonctionnalites:
#   - id: F1
#     resume: "Calculer le salaire net à partir du salaire brut pour chaque employé."
# 
# exigences:
#   - id: R1
#     type: regle_metier
#     regle: "SALARY_NET = ROUND(SALARY_BRUT * 0.7, 2)"
#     notes: "Salaire net = salaire brut − cotisations sociales (20%) − impôt (10%). Arrondi bancaire à 2 décimales. SALARY_NET ne doit pas être négatif."
#   - id: R2
#     type: technique
#     regle: "Traitement batch quotidien; journalisation des exécutions."
#   - id: R3
#     type: validation
#     regle: "Si SALARY_BRUT est NULL ou invalide, ignorer la ligne ou la signaler en anomalie."
# 
# mcd:
#   entites:
#     - name: EMPLOYEE
#       attrs:
#         - name: EMP_ID
#           type: INT
#           sql_type: INT
#           cobol_pic: "9(4)"
#           pk: true
#           nullable: false
#         - name: EMP_NAME
#           type: VARCHAR(30)
#           sql_type: VARCHAR(30)
#           cobol_pic: "A(30)"
#           nullable: false
#         - name: SALARY_BRUT
#           type: DECIMAL(8,2)
#           sql_type: DECIMAL(8,2)
#           cobol_pic: "9(6)V99"
#           nullable: false
#         - name: SALARY_NET
#           type: DECIMAL(8,2)
#           sql_type: DECIMAL(8,2)
#           cobol_pic: "9(6)V99"
#           nullable: true
#   relations: []
# 
# diagramme: |
#   erDiagram
#     EMPLOYEE {
#       INT EMP_ID PK
#       VARCHAR EMP_NAME
#       DECIMAL SALARY_BRUT
#       DECIMAL SALARY_NET
#     }
# 
# sql:
#   # DDL exact à générer (rien à deviner)
#   ddl:
#     EMPLOYEE: |
#       CREATE TABLE EMPLOYEE (
#           EMP_ID INT PRIMARY KEY,
#           EMP_NAME VARCHAR(30),
#           SALARY_BRUT DECIMAL(8,2),
#           SALARY_NET DECIMAL(8,2)
#       );
#   # Données initiales exactes
#   initial_data:
#     EMPLOYEE:
#       - EMP_ID: 1
#         EMP_NAME: "Dupont"
#         SALARY_BRUT: 3000.00
#         SALARY_NET: 0.00
#   indexes:
#     - entity: EMPLOYEE
#       name: EMPLOYEE_EMP_NAME_IDX
#       columns: [EMP_NAME]
# 
# # Règles générales de mapping (pour d'autres cas réutilisables)
# mapping_types:
#   - sql: "INT"
#     cobol_pic_default: "9(4)"
#   - sql: "VARCHAR(30)"
#     cobol_pic_default: "A(30)"
#   - sql: "DECIMAL(8,2)"
#     cobol_pic_default: "9(6)V99"
# 
# technique:
#   cursor_naming:
#     pattern: "C_<ENTITY_UPPER3>"
#     example:
#       EMPLOYEE: "C_EMP"
#   eof_flag:
#     name: "END-OF-FILE"
#     pic: "X"
#     initial_value: "N"
#     true_value: "Y"
#     false_value: "N"
#   sqlca_required: true   # la DAL doit inclure SQLCA dès qu'elle utilise SQLCODE
# 
# programmes:
#   - name: EMPLOYEE-DAL-DB
#     layer: dal
#     role: "Couche physique d'accès à la base pour EMPLOYEE (curseur + update SALARY_NET)."
#     entities: [EMPLOYEE]
#     allowed_sql: true
#     allowed_business_logic: false
#     main_cursor: "C_EMP"
# 
#   - name: EMPLOYEE-LOGIC
#     layer: logic
#     role: "Traitement batch principal : boucle sur les employés, appel DAL + calcul salaire net."
#     entities: [EMPLOYEE]
#     allowed_sql: false
#     allowed_business_logic: true
# 
#   - name: EMPLOYEE-BUSINESS
#     layer: business
#     role: "Affichage simple des informations d'un employé."
#     entities: [EMPLOYEE]
#     allowed_sql: false
#     allowed_business_logic: lecture_seule
# 
# fonctions:
#   # --- Couche DAL / Physique ---
# 
#   - id: FN-DAL-OPEN
#     name: OPEN-CURSOR
#     programme: EMPLOYEE-DAL-DB
#     layer: dal
#     entity: EMPLOYEE
#     description: >
#       Ouvre le curseur SQL pour parcourir toutes les lignes de la table EMPLOYEE.
#     inputs: []
#     outputs:
#       - "SQLCODE"
#     modifies:
#       - "SQLCODE"
#     preconditions: []
#     postconditions:
#       - "Si SQLCODE = 0, le curseur C_EMP est ouvert et prêt à lire le premier employé."
#     errors_flags:
#       - "SQLCODE = 0 : succès."
#       - "SQLCODE != 0 : erreur d'ouverture de curseur (à journaliser selon R2)."
#     related_exigences: [R2]
#     sql:
#       declare_cursor: |
#         DECLARE C_EMP CURSOR FOR
#         SELECT EMP_ID, EMP_NAME, SALARY_BRUT, SALARY_NET
#         FROM EMPLOYEE
#       open_cursor: "OPEN C_EMP"
# 
#   - id: FN-DAL-READ
#     name: READ-EMPLOYEE
#     programme: EMPLOYEE-DAL-DB
#     layer: dal
#     entity: EMPLOYEE
#     description: >
#       Lit le prochain employé via le curseur C_EMP et remplit la structure EMPLOYEE.
#       Met à jour END-OF-FILE en fonction de la présence ou non d'une ligne suivante.
#     inputs:
#       - "curseur C_EMP déjà ouvert"
#     outputs:
#       - "EMPLOYEE.EMP_ID"
#       - "EMPLOYEE.EMP_NAME"
#       - "EMPLOYEE.SALARY_BRUT"
#       - "EMPLOYEE.SALARY_NET"
#       - "END-OF-FILE"
#       - "SQLCODE"
#     modifies:
#       - "EMPLOYEE.EMP_ID"
#       - "EMPLOYEE.EMP_NAME"
#       - "EMPLOYEE.SALARY_BRUT"
#       - "EMPLOYEE.SALARY_NET"
#       - "END-OF-FILE"
#       - "SQLCODE"
#     preconditions:
#       - "Le curseur C_EMP a été ouvert avec succès (SQLCODE = 0 lors de OPEN-CURSOR)."
#     postconditions:
#       - "Si SQLCODE = 0 : EMPLOYEE contient un enregistrement valide et END-OF-FILE = 'N'."
#       - "Si SQLCODE = 100 : fin de données, END-OF-FILE = 'Y'."
#     errors_flags:
#       - "SQLCODE = 0 : ligne lue."
#       - "SQLCODE = 100 : fin du curseur, plus de lignes."
#       - "SQLCODE != 0 et != 100 : erreur SQL (à journaliser)."
#     related_exigences: [R2, R3]
#     sql:
#       fetch_into: "FETCH C_EMP INTO :EMP-ID, :EMP-NAME, :SALARY-BRUT, :SALARY-NET"
#     eof_logic:
#       on_sqlcode_100_set_eof: true
# 
#   - id: FN-DAL-SAVE
#     name: SAVE-EMPLOYEE
#     programme: EMPLOYEE-DAL-DB
#     layer: dal
#     entity: EMPLOYEE
#     description: >
#       Met à jour en base la colonne SALARY_NET de la table EMPLOYEE pour l'identifiant EMP_ID courant,
#       en utilisant la valeur SALARY_NET de la structure EMPLOYEE.
#     inputs:
#       - "EMPLOYEE.EMP_ID"
#       - "EMPLOYEE.SALARY_NET"
#     outputs:
#       - "SQLCODE"
#     modifies:
#       - "SQLCODE"
#     preconditions:
#       - "EMPLOYEE.EMP_ID est renseigné."
#       - "EMPLOYEE.SALARY_NET contient une valeur calculée et valide (>= 0)."
#     postconditions:
#       - "Si SQLCODE = 0 : la ligne EMPLOYEE correspondante en base a été mise à jour."
#     errors_flags:
#       - "SQLCODE = 0 : succès."
#       - "SQLCODE != 0 : erreur SQL lors de la mise à jour (à journaliser)."
#     related_exigences: [R1, R2]
#     sql:
#       update_statement: |
#         UPDATE EMPLOYEE
#         SET SALARY_NET = :SALARY-NET
#         WHERE EMP_ID = :EMP-ID
# 
#   # --- Couche LOGIQUE / Orchestration batch ---
# 
#   - id: FN-LOGIC-MAIN
#     name: MAIN-PROCESS
#     programme: EMPLOYEE-LOGIC
#     layer: logic
#     entity: EMPLOYEE
#     description: >
#       Traitement batch principal : pour chaque employé lu depuis la DAL,
#       applique la règle métier de calcul du salaire net puis sauvegarde le résultat en base.
#       S'arrête lorsque la DAL indique qu'il n'y a plus d'employés à traiter.
#     inputs: []
#     outputs: []
#     modifies:
#       - "EMPLOYEE.*"
#       - "END-OF-FILE"
#     preconditions: []
#     postconditions:
#       - "Tous les employés éligibles ont un SALARY_NET recalculé en base selon la règle R1."
#     calls:
#       - "EMPLOYEE-DAL-DB.OPEN-CURSOR"
#       - "EMPLOYEE-DAL-DB.READ-EMPLOYEE"
#       - "CALCULATE-NET"
#       - "EMPLOYEE-DAL-DB.SAVE-EMPLOYEE"
#     loop_control:
#       uses_eof_flag: "END-OF-FILE"
#       eof_true_value: "Y"
#       eof_false_value: "N"
#     errors_flags:
#       - "Doit gérer les erreurs SQL (SQLCODE != 0) en journalisant les anomalies (R2)."
#       - "Doit ignorer ou signaler les lignes où SALARY_BRUT est invalide (R3)."
#     related_exigences: [F1, R1, R2, R3]
# 
#   - id: FN-LOGIC-CALC
#     name: CALCULATE-NET
#     programme: EMPLOYEE-LOGIC
#     layer: logic
#     entity: EMPLOYEE
#     description: >
#       Applique la règle métier SALARY_NET = ROUND(SALARY_BRUT * 0.7, 2) à l'employé courant.
#       Cette fonction ne fait aucun accès base ; elle manipule uniquement la structure EMPLOYEE en mémoire.
#     inputs:
#       - "EMPLOYEE.SALARY_BRUT"
#     outputs:
#       - "EMPLOYEE.SALARY_NET"
#     modifies:
#       - "EMPLOYEE.SALARY_NET"
#     preconditions:
#       - "EMPLOYEE.SALARY_BRUT n'est pas NULL."
#     postconditions:
#       - "EMPLOYEE.SALARY_NET >= 0."
#       - "EMPLOYEE.SALARY_NET correspond à SALARY_BRUT * 0.7 arrondi à 2 décimales (logique métier R1)."
#     errors_flags:
#       - "Si SALARY_BRUT est invalide, la ligne doit être ignorée ou signalée selon la politique de R3."
#     related_exigences: [R1, R3]
#     expression:
#       target: "EMPLOYEE.SALARY_NET"
#       formula: "ROUND(EMPLOYEE.SALARY_BRUT * 0.7, 2)"
#       cobol_hint: "COMPUTE SALARY-NET = SALARY-BRUT * 0.7. * Arrondi à deux décimales si nécessaire"
# 
#   # --- Couche MÉTIER / Présentation ---
# 
#   - id: FN-BIZ-DISPLAY
#     name: DISPLAY-EMPLOYEE
#     programme: EMPLOYEE-BUSINESS
#     layer: business
#     entity: EMPLOYEE
#     description: >
#       Affiche les informations principales de l'employé (nom, salaire brut, salaire net)
#       pour contrôle, debug ou restitution simple.
#     inputs:
#       - "EMPLOYEE.EMP_NAME"
#       - "EMPLOYEE.SALARY_BRUT"
#       - "EMPLOYEE.SALARY_NET"
#     outputs: []
#     modifies: []
#     preconditions:
#       - "La structure EMPLOYEE contient des données cohérentes pour l'employé à afficher."
#     postconditions: []
#     errors_flags: []
#     related_exigences: [F1]
#     display_lines:
#       - 'DISPLAY "Employé:" EMP-NAME'
#       - 'DISPLAY "Salaire Brut:" SALARY-BRUT'
#       - 'DISPLAY "Salaire Net:" SALARY-NET'
# # # Exemple 1 — Salaire net (NET = BRUT * 0.7 arrondi à 2 décimales)
# # title: CALCUL-SALAIRE
# # dialecte_cobol: gnucobol
# # sql_cible: postgres
# # nommage:
# #   variables_case: UPPER_SNAKE
# #   programmes_case: UPPER-KEBAB
# # 
# # fonctionnalites:
# #   - id: F1
# #     resume: Calculer le salaire net à partir du salaire brut pour chaque employé.
# # 
# # exigences:
# #   - id: R1
# #     type: regle_metier
# #     regle: "SALARY_NET = ROUND(SALARY_BRUT * 0.7, 2)"
# #     notes: "Arrondi bancaire à 2 décimales. SALARY_NET ne doit pas être négatif."
# #   - id: R2
# #     type: technique
# #     regle: "Traitement batch quotidien; journalisation des exécutions."
# #   - id: R3
# #     type: validation
# #     regle: "Si SALARY_BRUT est NULL, ignorer la ligne ou la signaler en anomalie."
# # 
# # mcd:
# #   entites:
# #     - name: EMPLOYEE
# #       attrs:
# #         - name: EMP_ID
# #           type: INT
# #           pk: true
# #           nullable: false
# #         - name: EMP_NAME
# #           type: VARCHAR(30)
# #           nullable: false
# #         - name: SALARY_BRUT
# #           type: DECIMAL(10,2)
# #           nullable: false
# #         - name: SALARY_NET
# #           type: DECIMAL(10,2)
# #           nullable: true
# #   relations: []
# # 
# # diagramme: |
# #   erDiagram
# #     EMPLOYEE {
# #       INT EMP_ID PK
# #       VARCHAR EMP_NAME
# #       DECIMAL SALARY_BRUT
# #       DECIMAL SALARY_NET
# #     }
# # 
# # # (Optionnel) Indices/contraintes SQL additionnels compréhensibles par le générateur
# # sql:
# #   indexes:
# #     - entity: EMPLOYEE
# #       name: EMPLOYEE_EMP_NAME_IDX
# #       columns: [EMP_NAME]
