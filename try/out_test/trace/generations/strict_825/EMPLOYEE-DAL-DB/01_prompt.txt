Reponds uniquement avec du code COBOL compilable, sans Markdown ni texte autour.
La premiere ligne doit etre IDENTIFICATION DIVISION.
Un seul PROGRAM-ID, pas de sous-programmes.
Utilise strictement les identifiants, messages, SQL et sequences definis dans la spec.
N'invente aucune variable, paragraphe, message ou SQL.
Respecte exactement les listes de WORKING-STORAGE, LINKAGE et USING.
Toujours utiliser les terminateurs explicites END-IF / END-EVALUATE / END-PERFORM / END-EXEC.
Pas de GO TO, pas de logique DAL dans LOGIC, pas de SQL hors DAL.
Toute variable utilisee doit etre declaree (WORKING-STORAGE ou LINKAGE).
Chaque paragraphe DOIT etre declare sur une ligne avec un point (ex: MAIN-ENTRY.).
Ne termine aucune instruction par un point (sauf EXEC SQL INCLUDE SQLCA END-EXEC.); seul un point sur une ligne seule termine un paragraphe.

=== STRATEGY ===
1) Construis d'abord le squelette COBOL complet (DIVISION/SECTION) dans l'ordre.
2) Insere les blocs WORKING-STORAGE/LINKAGE exacts fournis par la spec.
3) Ecris la PROCEDURE DIVISION en suivant le flow et les fonctions.
4) Verifie la coherence: aucune variable/paragraphes inventes.

=== CONTEXT ===
SGBD: postgres. Dialecte COBOL: gnucobol.
Table EMPLOYEE: EMP_ID INT PK, EMP_NAME VARCHAR(30), SALARY_BRUT DECIMAL(8,2), SALARY_NET DECIMAL(8,2)
Role: couche DAL pour EMPLOYEE.

=== STYLE ===
Guidelines globales: Format FIXED: instructions commencent en colonne 8 (prefixe de 7 espaces).
Commentaires: '*' en colonne 7 (6 espaces + '*'), pas de commentaires '*>'.
Ne pas utiliser '>>SOURCE FORMAT FREE'.
Terminer chaque paragraphe par une ligne avec un seul point.
Le nom du paragraphe se termine par un point (ex: MAIN-ENTRY.).
Aucune ligne ne doit depasser 72 colonnes (format FIXED).
Si une instruction depasse 72 colonnes, la scinder sur plusieurs lignes.
Pour EXEC SQL FETCH/SELECT/UPDATE: mettre chaque variable hote sur sa propre ligne.
Ne pas mettre de point en fin de DISPLAY/GOBACK/STOP RUN/CALL/MOVE/IF (sauf EXEC SQL INCLUDE SQLCA END-EXEC.).
Utiliser des guillemets simples pour les messages DISPLAY.
Respecter l'ordre: IDENTIFICATION -> ENVIRONMENT -> DATA -> PROCEDURE.
Dans DATA: WORKING-STORAGE puis LINKAGE (si present).
Header commentaire (verbatim):
      *****************************************************************
      * Programme: EMPLOYEE-DAL-DB                                     *
      * Couche: DAL (Data Access Layer)                                *
      * Role: Acces a la base PostgreSQL pour EMPLOYEE                 *
      *       Operations: READ, SAVE, END                              *
      *****************************************************************
Style specifique: CALL OCESQL avec guillemets doubles et END-CALL.
OCESQLConnect avec BY REFERENCE/ BY VALUE (ordre exact).
EXIT PARAGRAPH sur erreur OPEN du curseur.
EVALUATE SQLCODE apres FETCH.
Apres DAL-CONNECT, si NOT WS-CONNECTED: MOVE 'Y' TO LK-END-OF-FILE puis GOBACK.
MAIN-ENTRY se termine strictement par END-EVALUATE, puis GOBACK, puis '.'

=== FORMAT ===
Format COBOL: line_format: fixed
indent_spaces: 7
max_line_length: 72
comment: column=7, prefix=*
literal_quotes: single
paragraph_terminator: .
allow_source_format_directive: False

=== NAMING ===
Conventions de nommage: variables_case=UPPER_SNAKE, programmes_case=UPPER-KEBAB
prefixes: flags=WS-, linkage=LK-, working_storage=WS-
paragraph_style: VERB-NOUN

=== ENVIRONMENT ===
ENVIRONMENT exact (lignes):
ENVIRONMENT DIVISION.
CONFIGURATION SECTION.
REPOSITORY.
    FUNCTION ALL INTRINSIC.

=== INTERFACE ===
Interface CALL/USING attendue: LK-OPERATION: X(4) (direction: in); LK-END-OF-FILE: X (direction: inout); LK-EMPLOYEE: groupe EMPLOYEE (direction: inout)

=== STRUCTURE ===
LINKAGE attendu (exemple exact):
LINKAGE SECTION.
01 LK-OPERATION PIC X(4).
01 LK-END-OF-FILE PIC X.
01 LK-EMPLOYEE.
    05 LK-EMP-ID PIC 9(4).
    05 LK-EMP-NAME PIC A(30).
    05 LK-SALARY-BRUT PIC S9(6)V99.
    05 LK-SALARY-NET PIC S9(6)V99.

PROCEDURE DIVISION USING LK-OPERATION LK-END-OF-FILE LK-EMPLOYEE.

=== WORKING_STORAGE ===
Working-Storage obligatoire (lignes exactes, ordre conseille):
EXEC SQL INCLUDE SQLCA END-EXEC.
01  WS-CONNECTED-FLAG      PIC X VALUE 'N'.
88  WS-CONNECTED           VALUE 'Y'.
01  WS-CURSOR-OPEN-FLAG    PIC X VALUE 'N'.
88  WS-CURSOR-OPEN         VALUE 'Y'.
01  WS-EMP-ID              PIC 9(4).
01  WS-EMP-NAME            PIC A(30).
01  WS-SALARY-BRUT         PIC S9(6)V99.
01  WS-SALARY-NET          PIC S9(6)V99.
01  WS-DB-NAME.
05  WS-DB-NAME-TEXT     PIC X(5) VALUE 'empdb'.
05  WS-DB-NAME-TERM     PIC X VALUE X'00'.
01  WS-DB-USER.
05  WS-DB-USER-TEXT     PIC X(7) VALUE 'empuser'.
05  WS-DB-USER-TERM     PIC X VALUE X'00'.
01  WS-DB-PASSWORD.
05  WS-DB-PASSWORD-TEXT PIC X(9) VALUE 'SECRETPWD'.
05  WS-DB-PASSWORD-TERM PIC X VALUE X'00'.
01  WS-DB-NAME-LEN         PIC S9(4) COMP-5 VALUE 5.
01  WS-DB-USER-LEN         PIC S9(4) COMP-5 VALUE 7.
01  WS-DB-PASSWORD-LEN     PIC S9(4) COMP-5 VALUE 9.
01  WS-PGHOST-NAME         PIC X(6) VALUE 'PGHOST'.
01  WS-PGHOST-VALUE        PIC X(64) VALUE 'localhost'.
01  WS-PGPORT-NAME         PIC X(6) VALUE 'PGPORT'.
01  WS-PGPORT-VALUE        PIC X(5) VALUE '5432'.
01  WS-PGUSER-NAME         PIC X(6) VALUE 'PGUSER'.
01  WS-PGUSER-VALUE        PIC X(64) VALUE 'empuser'.
01  WS-PGPASSWORD-NAME     PIC X(10) VALUE 'PGPASSWORD'.
01  WS-PGPASSWORD-VALUE    PIC X(64) VALUE 'SECRETPWD'.
01  WS-PGDATABASE-NAME     PIC X(10) VALUE 'PGDATABASE'.
01  WS-PGDATABASE-VALUE    PIC X(64) VALUE 'empdb'.

=== SQL ===
Connexion OCESQL: engine=postgres, method=ocesql, host=localhost, port=5432, dbname=empdb, user=empuser
env_vars: PGDATABASE=empdb, PGHOST=localhost, PGPASSWORD=SECRETPWD, PGPORT=5432, PGUSER=empuser
env_set_method: DISPLAY <ENV_NAME> UPON ENVIRONMENT-NAME | DISPLAY <ENV_VALUE> UPON ENVIRONMENT-VALUE
OCESQL calls: OCESQLStartSQL, OCESQLConnect, OCESQLEndSQL
connect_args: SQLCA, WS-DB-USER, WS-DB-USER-LEN, WS-DB-PASSWORD, WS-DB-PASSWORD-LEN, WS-DB-NAME, WS-DB-NAME-LEN
order: SQLCA, user, user_len, password, password_len, dbname, dbname_len
SQL utilises:
DAL-CONNECT:
  connection_calls: CALL "OCESQLStartSQL" END-CALL
  connection_calls: CALL "OCESQLConnect" USING BY REFERENCE SQLCA BY REFERENCE WS-DB-USER BY VALUE WS-DB-USER-LEN BY REFERENCE WS-DB-PASSWORD BY VALUE WS-DB-PASSWORD-LEN BY REFERENCE WS-DB-NAME BY VALUE WS-DB-NAME-LEN END-CALL
  connection_calls: CALL "OCESQLEndSQL" END-CALL
  connection_method: OCESQL (voir sql.connection)
DAL-READ:
  declare_cursor: DECLARE C_EMP CURSOR FOR
SELECT EMP_ID, EMP_NAME, SALARY_BRUT, SALARY_NET
FROM EMPLOYEE
ORDER BY EMP_ID

  fetch_into: FETCH C_EMP INTO :WS-EMP-ID, :WS-EMP-NAME, :WS-SALARY-BRUT, :WS-SALARY-NET
  open_cursor: OPEN C_EMP
DAL-SAVE:
  update_statement: UPDATE EMPLOYEE
SET SALARY_NET = :WS-SALARY-NET
WHERE EMP_ID = :WS-EMP-ID

DAL-END:
  close_cursor: CLOSE C_EMP
  commit: COMMIT
  disconnect: DISCONNECT ALL

=== SQL_FORMAT ===
Format SQL en FIXED:
max_line_length: 72
host_vars_one_per_line: True
split_long_exec_sql: True

=== SQL_BEHAVIOR ===
check_sqlcode: True
check_sqlstate: True
sqlcode_success: 0
sqlcode_eof: 100
rollback_on_error: False
commit: mode=end, statement=EXEC SQL COMMIT END-EXEC.
disconnect: statement=EXEC SQL DISCONNECT ALL END-EXEC.
null_indicators: False
cursor_commit_policy: no_commit_while_open

=== FLOW ===
Flux principal DAL:
MAIN-ENTRY: IF LK-OPERATION NOT = 'END ' THEN PERFORM DAL-CONNECT; IF NOT WS-CONNECTED THEN MOVE 'Y' TO LK-END-OF-FILE, GOBACK; END-IF; END-IF
EVALUATE LK-OPERATION: READ->DAL-READ, SAVE->DAL-SAVE, END->DAL-END, OTHER->DISPLAY erreur
GOBACK apres EVALUATE
DAL-READ: ouverture curseur paresseuse, FETCH, mise a jour EOF
DAL-SAVE: UPDATE SALARY_NET
DAL-END: CLOSE cursor, COMMIT, DISCONNECT, reset flags

=== LOGGING ===
Messages (verbatim) a afficher:
Connexion DB reussie: empdb
ERREUR CONNECT: SQLCODE=
SQLSTATE=
SQLERRMC=
Curseur C_EMP ouvert
ERREUR OPEN: SQLCODE=
ERREUR FETCH: SQLCODE=
ERREUR UPDATE: SQLCODE=
ERREUR CLOSE: SQLCODE=
ERREUR COMMIT: SQLCODE=
ERREUR DISCONNECT: SQLCODE=
ERREUR: Operation inconnue: 
Fermeture connexion

=== CONSTRAINTS ===
Interdictions: GO TO, *>
Paragraphes publics attendus: DAL-READ, DAL-SAVE, DAL-END
Paragraphes internes autorises: DAL-CONNECT, DAL-SET-ENV, DAL-CONNECT, DAL-SET-ENV
Entry paragraph: MAIN-ENTRY
Regles de bloc MAIN-ENTRY: condition: ^\s*IF\s+LK-OPERATION\s+NOT\s+(=|EQUAL)\s+'END '\s*$
must_contain:
  - PERFORM DAL-CONNECT
  - IF NOT WS-CONNECTED
  - MOVE 'Y' TO LK-END-OF-FILE
  - GOBACK
Sequence de sortie MAIN-ENTRY: paragraph: MAIN-ENTRY
must_follow_order:
  - END-EVALUATE
  - GOBACK
  - .
Contraintes par paragraphe: paragraph: DAL-READ
forbid_contains:
  - PERFORM DAL-CONNECT
  - IF NOT WS-CONNECTED
Statements obligatoires: GOBACK, END-CALL, BY REFERENCE, BY VALUE, EXIT PARAGRAPH, EVALUATE SQLCODE

=== SKELETON ===
Squelette attendu (rappel structure):
IDENTIFICATION DIVISION.
PROGRAM-ID. EMPLOYEE-DAL-DB.
      *****************************************************************
      * Programme: EMPLOYEE-DAL-DB                                     *
      * Couche: DAL (Data Access Layer)                                *
      * Role: Acces a la base PostgreSQL pour EMPLOYEE                 *
      *       Operations: READ, SAVE, END                              *
      *****************************************************************
ENVIRONMENT DIVISION.
CONFIGURATION SECTION.
REPOSITORY.
    FUNCTION ALL INTRINSIC.
DATA DIVISION.
WORKING-STORAGE SECTION.
EXEC SQL INCLUDE SQLCA END-EXEC.
01  WS-CONNECTED-FLAG      PIC X VALUE 'N'.
88  WS-CONNECTED           VALUE 'Y'.
01  WS-CURSOR-OPEN-FLAG    PIC X VALUE 'N'.
88  WS-CURSOR-OPEN         VALUE 'Y'.
01  WS-EMP-ID              PIC 9(4).
01  WS-EMP-NAME            PIC A(30).
01  WS-SALARY-BRUT         PIC S9(6)V99.
01  WS-SALARY-NET          PIC S9(6)V99.
01  WS-DB-NAME.
05  WS-DB-NAME-TEXT     PIC X(5) VALUE 'empdb'.
05  WS-DB-NAME-TERM     PIC X VALUE X'00'.
01  WS-DB-USER.
05  WS-DB-USER-TEXT     PIC X(7) VALUE 'empuser'.
05  WS-DB-USER-TERM     PIC X VALUE X'00'.
01  WS-DB-PASSWORD.
05  WS-DB-PASSWORD-TEXT PIC X(9) VALUE 'SECRETPWD'.
05  WS-DB-PASSWORD-TERM PIC X VALUE X'00'.
01  WS-DB-NAME-LEN         PIC S9(4) COMP-5 VALUE 5.
01  WS-DB-USER-LEN         PIC S9(4) COMP-5 VALUE 7.
01  WS-DB-PASSWORD-LEN     PIC S9(4) COMP-5 VALUE 9.
01  WS-PGHOST-NAME         PIC X(6) VALUE 'PGHOST'.
01  WS-PGHOST-VALUE        PIC X(64) VALUE 'localhost'.
01  WS-PGPORT-NAME         PIC X(6) VALUE 'PGPORT'.
01  WS-PGPORT-VALUE        PIC X(5) VALUE '5432'.
01  WS-PGUSER-NAME         PIC X(6) VALUE 'PGUSER'.
01  WS-PGUSER-VALUE        PIC X(64) VALUE 'empuser'.
01  WS-PGPASSWORD-NAME     PIC X(10) VALUE 'PGPASSWORD'.
01  WS-PGPASSWORD-VALUE    PIC X(64) VALUE 'SECRETPWD'.
01  WS-PGDATABASE-NAME     PIC X(10) VALUE 'PGDATABASE'.
01  WS-PGDATABASE-VALUE    PIC X(64) VALUE 'empdb'.
LINKAGE/USING exacts:
LINKAGE SECTION.
01 LK-OPERATION PIC X(4).
01 LK-END-OF-FILE PIC X.
01 LK-EMPLOYEE.
    05 LK-EMP-ID PIC 9(4).
    05 LK-EMP-NAME PIC A(30).
    05 LK-SALARY-BRUT PIC S9(6)V99.
    05 LK-SALARY-NET PIC S9(6)V99.

PROCEDURE DIVISION USING LK-OPERATION LK-END-OF-FILE LK-EMPLOYEE.
MAIN-ENTRY.

=== FONCTIONS ===
- DAL-CONNECT: Connexion paresseuse a la base via OCESQL. Initialise les variables d'environnement PostgreSQL, puis execute OCESQLStartSQL/OCESQLConnect/OCESQLEndSQL.

  visibility: internal, required: True
  Outputs: SQLCODE, SQLSTATE
  Steps:
    - IF NOT WS-CONNECTED
    -   PERFORM DAL-SET-ENV
    -   CALL "OCESQLStartSQL" END-CALL
    -   CALL "OCESQLConnect" USING
    -        BY REFERENCE SQLCA
    -        BY REFERENCE WS-DB-USER
    -        BY VALUE WS-DB-USER-LEN
    -        BY REFERENCE WS-DB-PASSWORD
    -        BY VALUE WS-DB-PASSWORD-LEN
    -        BY REFERENCE WS-DB-NAME
    -        BY VALUE WS-DB-NAME-LEN
    -   END-CALL
    -   CALL "OCESQLEndSQL" END-CALL
    - SQLCODE=0: SET WS-CONNECTED TO TRUE, DISPLAY 'Connexion DB reussie: empdb'
    - Sinon: DISPLAY 'ERREUR CONNECT: SQLCODE=' SQLCODE, DISPLAY 'SQLSTATE=' SQLSTATE, DISPLAY 'SQLERRMC=' SQLERRMC
    - END-IF
  Emplacement: division=PROCEDURE DIVISION, section=couche_dal, paragraphe=DAL-CONNECT
- DAL-SET-ENV: Force les variables d'environnement PGHOST/PGPORT/PGUSER/PGPASSWORD/PGDATABASE.

  visibility: internal, required: True
  Steps:
    - DISPLAY WS-PGHOST-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGHOST-VALUE UPON ENVIRONMENT-VALUE
    - DISPLAY WS-PGPORT-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGPORT-VALUE UPON ENVIRONMENT-VALUE
    - DISPLAY WS-PGUSER-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGUSER-VALUE UPON ENVIRONMENT-VALUE
    - DISPLAY WS-PGPASSWORD-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGPASSWORD-VALUE UPON ENVIRONMENT-VALUE
    - DISPLAY WS-PGDATABASE-NAME UPON ENVIRONMENT-NAME
    - DISPLAY WS-PGDATABASE-VALUE UPON ENVIRONMENT-VALUE
  Emplacement: division=PROCEDURE DIVISION, section=couche_dal, paragraphe=DAL-SET-ENV
- DAL-READ: Ouvre le curseur C_EMP si nécessaire, fait un FETCH et remplit la structure EMPLOYEE. Met END-OF-FILE à 'Y' en cas de fin de données ou d'erreur.

  visibility: public, required: True
  Inputs: OPERATION = 'READ', Connexion déjà établie par MAIN-ENTRY (sauf OPERATION='END ')., Curseur non garanti ouvert (ouverture paresseuse).
  Outputs: EMPLOYEE.EMP_ID, EMPLOYEE.EMP_NAME, EMPLOYEE.SALARY_BRUT, EMPLOYEE.SALARY_NET, END-OF-FILE, SQLCODE
  Steps:
    - Si curseur non ouvert: DECLARE C_EMP, OPEN C_EMP
    - Sur erreur OPEN: DISPLAY 'ERREUR OPEN: SQLCODE=' SQLCODE, EOF='Y', EXIT PARAGRAPH
    - Sur succes OPEN: SET WS-CURSOR-OPEN TO TRUE, SET WS-CONNECTED TO TRUE, DISPLAY 'Curseur C_EMP ouvert'
    - FETCH C_EMP INTO WS-EMP-ID, WS-EMP-NAME, WS-SALARY-BRUT, WS-SALARY-NET
    - EVALUATE SQLCODE
    -   WHEN 0: EOF='N', MOVE WS-* vers LK-*
    -   WHEN 100: EOF='Y'
    -   WHEN OTHER: DISPLAY 'ERREUR FETCH: SQLCODE=' SQLCODE, DISPLAY SQLSTATE, EOF='Y'
    - END-EVALUATE
  Emplacement: division=PROCEDURE DIVISION, section=couche_dal, paragraphe=DAL-READ
- DAL-SAVE: Met à jour en base la colonne SALARY_NET pour l'employé courant (EMP_ID) à partir de la valeur SALARY_NET de la structure EMPLOYEE.

  visibility: public, required: True
  Inputs: EMPLOYEE.EMP_ID, EMPLOYEE.SALARY_NET
  Outputs: SQLCODE
  Steps:
    - MOVE LK-EMP-ID TO WS-EMP-ID
    - MOVE LK-SALARY-NET TO WS-SALARY-NET
    - EXEC SQL UPDATE EMPLOYEE SET SALARY_NET = :WS-SALARY-NET WHERE EMP_ID = :WS-EMP-ID
    - Si SQLCODE != 0: DISPLAY 'ERREUR UPDATE: SQLCODE=' SQLCODE, DISPLAY 'SQLSTATE=' SQLSTATE, DISPLAY 'EMP_ID=' LK-EMP-ID
  Emplacement: division=PROCEDURE DIVISION, section=couche_dal, paragraphe=DAL-SAVE
- DAL-END: Ferme le curseur s'il est ouvert, commit la transaction et ferme la connexion à la base. Appelée une fois en fin de traitement.

  visibility: public, required: True
  Outputs: SQLCODE
  Steps:
    - Si curseur ouvert: EXEC SQL CLOSE C_EMP
    - Si SQLCODE != 0: DISPLAY 'ERREUR CLOSE: SQLCODE=' SQLCODE
    - MOVE 'N' TO WS-CURSOR-OPEN-FLAG
    - Si connecte: EXEC SQL COMMIT
    - Si SQLCODE != 0: DISPLAY 'ERREUR COMMIT: SQLCODE=' SQLCODE
    - EXEC SQL DISCONNECT ALL
    - Si SQLCODE != 0: DISPLAY 'ERREUR DISCONNECT: SQLCODE=' SQLCODE
    - MOVE 'N' TO WS-CONNECTED-FLAG
    - DISPLAY 'Fermeture connexion'
  Emplacement: division=PROCEDURE DIVISION, section=couche_dal, paragraphe=DAL-END

Tache : genere le programme COBOL complet respectant ces contraintes (code seulement).

Les erreurs suivantes ont été détectées, corrige-les strictement sans ajouter de texte explicatif:
- Point final interdit sur instruction (utiliser '.' uniquement sur ligne seule).
- END-IF manquant pour la condition de bloc MAIN-ENTRY.